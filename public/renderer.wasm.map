{"version":3,"sources":["~lib/rt/common.ts","assembly/externals/WebGL.ts","assembly/components/TestTriangle.ts","assembly/components/Renderer.ts","~lib/rt/stub.ts","~lib/util/error.ts","assembly/components/ShaderMaterial.ts","assembly/EntryPoint.ts","~lib/shared/typeinfo.ts","~lib/rt.ts","~lib/memory.ts","~lib/util/memory.ts"],"names":[],"mappings":"wnBIgCE,AAAI,EAAO,SAA+B,cAC1C,AAAY,IAnBZ,AAAI,AAsBY,AAFN,EAAS,KAEG,AADJ,AATV,AAAC,KAAmC,GAAY,QAZxC,AADA,AAAC,AAAC,AADA,IACsB,GAAM,GAAW,QAIvD,AAAI,AAAY,AADM,EAAa,AADjB,AAAO,AAAC,EAAY,GAAY,KAAU,KAAa,aAE1C,KAC7B,AAAI,AAAY,IAAe,SAGnC,AAAS,IAgBT,cAgDA,AAAI,EAAO,SAAgC,eAG3C,AADa,AAAmB,AADtB,AAAQ,AAAkB,EAAlB,OACoB,UAEtC,OACA,OACA,OACO,EAAM,6BFnEP,2BIlBA,OJmBA,OIfA,AAAI,AJgBJ,YIfoB,cAGuB,MAA3C,AAAqB,QAAsB,QAC3C,QAAsB,EAAc,KACpC,QAAuB,IAEsB,MAA7C,AAAuB,AL+uET,AK/uES,QL+uEG,QK9uE1B,ALk8EO,AKl8EP,QLk8EmB,EAAQ,KKj8E3B,AL6sEQ,AK7sER,QL6sEoB,IK3sEpB,EAAgB,ALquED,AKruEC,aAEhB,QAAsB,KAAe,IACrC,AL8oEO,AK9oEP,QL8oEmB,AK9oEG,KL8oEM,IK7oE5B,ALk6EM,AKl6EN,QLk6EkB,AKl6EG,6CL42B3B,EAAa,AAAwB,EAAW,OE/3B1C,OACA,EAAkC,UIJtC,AAAW,SAKX,AJGI,iBOcc,IAAlB,ECuHF,AAAI,ADvHM,EAAK,MC8Hf,AAAI,EAAO,MACiB,AACpB,AAAc,EAAO,MACvB,EAAO,EAAO,KACZ,AAAI,AAAC,KACL,AAAE,OACQ,SAAiB,uBAE7B,EAAO,EAAK,KACV,AAAW,EAAM,AAAU,QAC3B,EAAQ,KACR,EAAQ,KACR,EAAQ,UAId,MACY,SAAiB,mBAC3B,AAAE,YAGsB,AACpB,AAAc,EAAO,MACvB,EAAO,AAAC,EAAO,GAAK,KAClB,AAAI,AAAC,KACL,AAAU,EAAO,AAAE,QAAG,AAAS,AAAM,EAAN,cAEjC,EAAO,EAAK,KAEV,AAAW,EAAO,AADlB,EAAK,MACgB,AAAU,AAAM,EAAN,eAIrC,MACE,AAAU,EAAO,AAAE,QAAG,AAAS,AAAM,EAAN,sBR1K7B,AFqsEK,AErsEL,AIHJ,UNwsEqB,KAAK,KAAO,KAAM,OEpsEpB,MAA4B,MAA3C,AFgsEA,AEhsEA,QFgsEY,MK9qEZ,AL+hFK,AK/hFL,AJHA,ACbA,kBF+iFiB,AK/hFG,OAEpB,AAAkB,AL6zEC,AK7zED,QL6zEa,AK7zEc,KL6zEL,OK5zEK,MAA7C,ALkkFc,AKlkFd,QLkkF0B,EAAM,EAAM,GAAK,EAAY,EAAQ,IKjkF/D,AL0xEkB,AK1xElB,QL0xE8B,IC/xE9B,AAAe,ADitED,ACjtEC,YACK,MAApB,ADyoEK,ACzoEL,QDyoEiB,IAAQ,IQpoE/B,AAAsB,AADT,AAAM,EAAM,QPDM,MAAsC,MAA/D,ADiqEQ,ACjqER,QDiqEoB,IAAQ,EAAM,MC5pEd,MAApB,AD2wEK,AC3wEL,QD2wEiB,EAAM,EAAO,OGtsEpC","sourceRoot":"./renderer.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","type WebGLContextAttributes = i32;\n\nexport type GLenum = u32;\nexport type GLboolean = bool;\nexport type GLbitfield = u32;\nexport type GLbyte = i8;\nexport type GLshort = i16;\nexport type GLint = i32;\nexport type GLsizei = i32;\nexport type GLintptr = i32; //i64;\nexport type GLsizeiptr = i32; //i64;\nexport type GLubyte = u8;\nexport type GLushort = u16;\nexport type GLuint = u32;\nexport type GLfloat = f32;\nexport type GLclampf = f32;\nexport type GLuint64 = u32; //u64;\nexport type GLint64 = i32; //i64;\n\nexport type WebGLUniformLocation = i32;\nexport type TexImageSource = i32;\nexport type Int32List = i32;\nexport type Uint32List = i32;\nexport type Float32List = i32;\nexport type WebGLQuery = i32;\nexport type WebGLSampler = i32;\nexport type WebGLSync = i32;\nexport type WebGLTransformFeedback = i32;\nexport type ImageData = i32;\nexport type DOMString = string;\nexport type HTMLImageElement = externref;\nexport type HTMLVideoElement = externref;\nexport type WebGLVertexArrayObject = i32;\n\n// == debug function not part of WebGL\nexport declare function logi32(arg: i32): void;\nexport declare function logf32(arg: f32): void;\n// == Not a part of WebGL, but there must be a way to create and load images\n// export type ImageData = i32;\nexport declare function createImage(image_location: string): ImageData;\nexport declare function imageReady(image_id: ImageData): bool;\n\n// === WebGLContextAttributes ===\nexport const ALPHA_DEFAULT = true;\nexport const FALSE: GLboolean = false;\n\n//export declare function activateTexture(gl: WebGLContextAttributes, texture: WebGLTexture): void;\n\nexport declare function getAlpha(gl: WebGLContextAttributes): GLboolean;\nexport declare function setAlpha(gl: WebGLContextAttributes, value: GLboolean): void;\n\nexport const DEPTH_DEFAULT = true;\nexport declare function getDepth(gl: WebGLContextAttributes): GLboolean;\nexport declare function setDepth(gl: WebGLContextAttributes, value: GLboolean): void;\n\nexport const STENCIL_DEFAULT = false;\nexport declare function getStencil(gl: WebGLContextAttributes): GLboolean;\nexport declare function setStencil(gl: WebGLContextAttributes, value: GLboolean): void;\n\nexport const ANTIALIAS_DEFAULT = true;\nexport declare function getAntialias(gl: WebGLContextAttributes): GLboolean;\nexport declare function setAntialias(gl: WebGLContextAttributes, value: GLboolean): void;\n\nexport const PREMULTIPLIED_ALPHA_DEFAULT = true;\nexport declare function getPremultipliedAlpha(gl: WebGLContextAttributes): GLboolean;\nexport declare function setPremultipliedAlpha(gl: WebGLContextAttributes, value: GLboolean): void;\n\nexport const PRESERVE_DRAWING_BUFFER_DEFAULT = false;\nexport declare function getPreserveDrawingBuffer(gl: WebGLContextAttributes): GLboolean;\nexport declare function setPreserveDrawingBuffer(gl: WebGLContextAttributes, value: GLboolean): void;\n\n// === WebGLActiveInfo ===\n\ntype WebGLActiveInfo = externref;\n\nexport declare function getSize(gl: WebGLActiveInfo): GLint;\nexport declare function getType(gl: WebGLActiveInfo): GLenum;\nexport declare function getName(gl: WebGLActiveInfo): string;\n\n// === WebGLShaderPrecisionFormat ===\n\ntype WebGLShaderPrecisionFormat = externref;\n\nexport declare function getRangeMin(gl: WebGLShaderPrecisionFormat): GLint;\nexport declare function getRangeMax(gl: WebGLShaderPrecisionFormat): GLint;\nexport declare function getPrecision(gl: WebGLShaderPrecisionFormat): GLint;\n\n// === WebGLRenderingContextId ===\n\nexport type WebGLRenderingContextId = i32;\n\n/* ClearBufferMask */\nexport const DEPTH_BUFFER_BIT: GLenum = 0x00000100;\nexport const STENCIL_BUFFER_BIT: GLenum = 0x00000400;\nexport const COLOR_BUFFER_BIT: GLenum = 0x00004000;\n\n/* BeginMode */\nexport const POINTS: GLenum = 0x0000;\nexport const LINES: GLenum = 0x0001;\nexport const LINE_LOOP: GLenum = 0x0002;\nexport const LINE_STRIP: GLenum = 0x0003;\nexport const TRIANGLES: GLenum = 0x0004;\nexport const TRIANGLE_STRIP: GLenum = 0x0005;\nexport const TRIANGLE_FAN: GLenum = 0x0006;\n\n/* AlphaFunction (not supported in ES20) */\n/*      NEVER */\n/*      LESS */\n/*      EQUAL */\n/*      LEQUAL */\n/*      GREATER */\n/*      NOTEQUAL */\n/*      GEQUAL */\n/*      ALWAYS */\n\n/* BlendingFactorDest */\nexport const ZERO: GLenum = 0;\nexport const ONE: GLenum = 1;\nexport const SRC_COLOR: GLenum = 0x0300;\nexport const ONE_MINUS_SRC_COLOR: GLenum = 0x0301;\nexport const SRC_ALPHA: GLenum = 0x0302;\nexport const ONE_MINUS_SRC_ALPHA: GLenum = 0x0303;\nexport const DST_ALPHA: GLenum = 0x0304;\nexport const ONE_MINUS_DST_ALPHA: GLenum = 0x0305;\n\n/* BlendingFactorSrc */\n/*      ZERO */\n/*      ONE */\nexport const DST_COLOR: GLenum = 0x0306;\nexport const ONE_MINUS_DST_COLOR: GLenum = 0x0307;\nexport const SRC_ALPHA_SATURATE: GLenum = 0x0308;\n/*      SRC_ALPHA */\n/*      ONE_MINUS_SRC_ALPHA */\n/*      DST_ALPHA */\n/*      ONE_MINUS_DST_ALPHA */\n\n/* BlendEquationSeparate */\nexport const FUNC_ADD: GLenum = 0x8006;\nexport const BLEND_EQUATION: GLenum = 0x8009;\nexport const BLEND_EQUATION_RGB: GLenum = 0x8009;\nexport const BLEND_EQUATION_ALPHA: GLenum = 0x883D;\n\n/* BlendSubtract */\nexport const FUNC_SUBTRACT: GLenum = 0x800A;\nexport const FUNC_REVERSE_SUBTRACT: GLenum = 0x800B;\n\n/* Separate Blend Functions */\nexport const BLEND_DST_RGB: GLenum = 0x80C8;\nexport const BLEND_SRC_RGB: GLenum = 0x80C9;\nexport const BLEND_DST_ALPHA: GLenum = 0x80CA;\nexport const BLEND_SRC_ALPHA: GLenum = 0x80CB;\nexport const CONSTANT_COLOR: GLenum = 0x8001;\nexport const ONE_MINUS_CONSTANT_COLOR: GLenum = 0x8002;\nexport const CONSTANT_ALPHA: GLenum = 0x8003;\nexport const ONE_MINUS_CONSTANT_ALPHA: GLenum = 0x8004;\nexport const BLEND_COLOR: GLenum = 0x8005;\n\n/* Buffer Objects */\nexport const ARRAY_BUFFER: GLenum = 0x8892;\nexport const ELEMENT_ARRAY_BUFFER: GLenum = 0x8893;\nexport const ARRAY_BUFFER_BINDING: GLenum = 0x8894;\nexport const ELEMENT_ARRAY_BUFFER_BINDING: GLenum = 0x8895;\n\nexport const STREAM_DRAW: GLenum = 0x88E0;\nexport const STATIC_DRAW: GLenum = 0x88E4;\nexport const DYNAMIC_DRAW: GLenum = 0x88E8;\n\nexport const BUFFER_SIZE: GLenum = 0x8764;\nexport const BUFFER_USAGE: GLenum = 0x8765;\n\nexport const CURRENT_VERTEX_ATTRIB: GLenum = 0x8626;\n\n/* CullFaceMode */\nexport const FRONT: GLenum = 0x0404;\nexport const BACK: GLenum = 0x0405;\nexport const FRONT_AND_BACK: GLenum = 0x0408;\n\n/* DepthFunction */\n/*      NEVER */\n/*      LESS */\n/*      EQUAL */\n/*      LEQUAL */\n/*      GREATER */\n/*      NOTEQUAL */\n/*      GEQUAL */\n/*      ALWAYS */\n\n/* EnableCap */\n/* TEXTURE_2D */\nexport const CULL_FACE: GLenum = 0x0B44;\nexport const BLEND: GLenum = 0x0BE2;\nexport const DITHER: GLenum = 0x0BD0;\nexport const STENCIL_TEST: GLenum = 0x0B90;\nexport const DEPTH_TEST: GLenum = 0x0B71;\nexport const SCISSOR_TEST: GLenum = 0x0C11;\nexport const POLYGON_OFFSET_FILL: GLenum = 0x8037;\nexport const SAMPLE_ALPHA_TO_COVERAGE: GLenum = 0x809E;\nexport const SAMPLE_COVERAGE: GLenum = 0x80A0;\n\n/* ErrorCode */\nexport const NO_ERROR: GLenum = 0;\nexport const INVALID_ENUM: GLenum = 0x0500;\nexport const INVALID_VALUE: GLenum = 0x0501;\nexport const INVALID_OPERATION: GLenum = 0x0502;\nexport const OUT_OF_MEMORY: GLenum = 0x0505;\n\n/* FrontFaceDirection */\nexport const CW: GLenum = 0x0900;\nexport const CCW: GLenum = 0x0901;\n\n/* GetPName */\nexport const LINE_WIDTH: GLenum = 0x0B21;\nexport const ALIASED_POINT_SIZE_RANGE: GLenum = 0x846D;\nexport const ALIASED_LINE_WIDTH_RANGE: GLenum = 0x846E;\nexport const CULL_FACE_MODE: GLenum = 0x0B45;\nexport const FRONT_FACE: GLenum = 0x0B46;\nexport const DEPTH_RANGE: GLenum = 0x0B70;\nexport const DEPTH_WRITEMASK: GLenum = 0x0B72;\nexport const DEPTH_CLEAR_VALUE: GLenum = 0x0B73;\nexport const DEPTH_FUNC: GLenum = 0x0B74;\nexport const STENCIL_CLEAR_VALUE: GLenum = 0x0B91;\nexport const STENCIL_FUNC: GLenum = 0x0B92;\nexport const STENCIL_FAIL: GLenum = 0x0B94;\nexport const STENCIL_PASS_DEPTH_FAIL: GLenum = 0x0B95;\nexport const STENCIL_PASS_DEPTH_PASS: GLenum = 0x0B96;\nexport const STENCIL_REF: GLenum = 0x0B97;\nexport const STENCIL_VALUE_MASK: GLenum = 0x0B93;\nexport const STENCIL_WRITEMASK: GLenum = 0x0B98;\nexport const STENCIL_BACK_FUNC: GLenum = 0x8800;\nexport const STENCIL_BACK_FAIL: GLenum = 0x8801;\nexport const STENCIL_BACK_PASS_DEPTH_FAIL: GLenum = 0x8802;\nexport const STENCIL_BACK_PASS_DEPTH_PASS: GLenum = 0x8803;\nexport const STENCIL_BACK_REF: GLenum = 0x8CA3;\nexport const STENCIL_BACK_VALUE_MASK: GLenum = 0x8CA4;\nexport const STENCIL_BACK_WRITEMASK: GLenum = 0x8CA5;\nexport const VIEWPORT: GLenum = 0x0BA2;\nexport const SCISSOR_BOX: GLenum = 0x0C10;\n/*      SCISSOR_TEST */\nexport const COLOR_CLEAR_VALUE: GLenum = 0x0C22;\nexport const COLOR_WRITEMASK: GLenum = 0x0C23;\nexport const UNPACK_ALIGNMENT: GLenum = 0x0CF5;\nexport const PACK_ALIGNMENT: GLenum = 0x0D05;\nexport const MAX_TEXTURE_SIZE: GLenum = 0x0D33;\nexport const MAX_VIEWPORT_DIMS: GLenum = 0x0D3A;\nexport const SUBPIXEL_BITS: GLenum = 0x0D50;\nexport const RED_BITS: GLenum = 0x0D52;\nexport const GREEN_BITS: GLenum = 0x0D53;\nexport const BLUE_BITS: GLenum = 0x0D54;\nexport const ALPHA_BITS: GLenum = 0x0D55;\nexport const DEPTH_BITS: GLenum = 0x0D56;\nexport const STENCIL_BITS: GLenum = 0x0D57;\nexport const POLYGON_OFFSET_UNITS: GLenum = 0x2A00;\n/*      POLYGON_OFFSET_FILL */\nexport const POLYGON_OFFSET_FACTOR: GLenum = 0x8038;\nexport const TEXTURE_BINDING_2D: GLenum = 0x8069;\nexport const SAMPLE_BUFFERS: GLenum = 0x80A8;\nexport const SAMPLES: GLenum = 0x80A9;\nexport const SAMPLE_COVERAGE_VALUE: GLenum = 0x80AA;\nexport const SAMPLE_COVERAGE_INVERT: GLenum = 0x80AB;\n\n/* GetTextureParameter */\n/*      TEXTURE_MAG_FILTER */\n/*      TEXTURE_MIN_FILTER */\n/*      TEXTURE_WRAP_S */\n/*      TEXTURE_WRAP_T */\n\nexport const COMPRESSED_TEXTURE_FORMATS: GLenum = 0x86A3;\n\n/* HintMode */\nexport const DONT_CARE: GLenum = 0x1100;\nexport const FASTEST: GLenum = 0x1101;\nexport const NICEST: GLenum = 0x1102;\n\n/* HintTarget */\nexport const GENERATE_MIPMAP_HINT: GLenum = 0x8192;\n\n/* DataType */\nexport const BYTE: GLenum = 0x1400;\nexport const UNSIGNED_BYTE: GLenum = 0x1401;\nexport const SHORT: GLenum = 0x1402;\nexport const UNSIGNED_SHORT: GLenum = 0x1403;\nexport const INT: GLenum = 0x1404;\nexport const UNSIGNED_INT: GLenum = 0x1405;\nexport const FLOAT: GLenum = 0x1406;\n\n/* PixelFormat */\nexport const DEPTH_COMPONENT: GLenum = 0x1902;\nexport const ALPHA: GLenum = 0x1906;\nexport const RGB: GLenum = 0x1907;\nexport const RGBA: GLenum = 0x1908;\nexport const LUMINANCE: GLenum = 0x1909;\nexport const LUMINANCE_ALPHA: GLenum = 0x190A;\n\n/* PixelType */\n/*      UNSIGNED_BYTE */\nexport const UNSIGNED_SHORT_4_4_4_4: GLenum = 0x8033;\nexport const UNSIGNED_SHORT_5_5_5_1: GLenum = 0x8034;\nexport const UNSIGNED_SHORT_5_6_5: GLenum = 0x8363;\n\n/* Shaders */\nexport const FRAGMENT_SHADER: GLenum = 0x8B30;\nexport const VERTEX_SHADER: GLenum = 0x8B31;\nexport const MAX_VERTEX_ATTRIBS: GLenum = 0x8869;\nexport const MAX_VERTEX_UNIFORM_VECTORS: GLenum = 0x8DFB;\nexport const MAX_VARYING_VECTORS: GLenum = 0x8DFC;\nexport const MAX_COMBINED_TEXTURE_IMAGE_UNITS: GLenum = 0x8B4D;\nexport const MAX_VERTEX_TEXTURE_IMAGE_UNITS: GLenum = 0x8B4C;\nexport const MAX_TEXTURE_IMAGE_UNITS: GLenum = 0x8872;\nexport const MAX_FRAGMENT_UNIFORM_VECTORS: GLenum = 0x8DFD;\nexport const SHADER_TYPE: GLenum = 0x8B4F;\nexport const DELETE_STATUS: GLenum = 0x8B80;\nexport const LINK_STATUS: GLenum = 0x8B82;\nexport const VALIDATE_STATUS: GLenum = 0x8B83;\nexport const ATTACHED_SHADERS: GLenum = 0x8B85;\nexport const ACTIVE_UNIFORMS: GLenum = 0x8B86;\nexport const ACTIVE_ATTRIBUTES: GLenum = 0x8B89;\nexport const SHADING_LANGUAGE_VERSION: GLenum = 0x8B8C;\nexport const CURRENT_PROGRAM: GLenum = 0x8B8D;\n\n/* StencilFunction */\nexport const NEVER: GLenum = 0x0200;\nexport const LESS: GLenum = 0x0201;\nexport const EQUAL: GLenum = 0x0202;\nexport const LEQUAL: GLenum = 0x0203;\nexport const GREATER: GLenum = 0x0204;\nexport const NOTEQUAL: GLenum = 0x0205;\nexport const GEQUAL: GLenum = 0x0206;\nexport const ALWAYS: GLenum = 0x0207;\n\n/* StencilOp */\n/*      ZERO */\nexport const KEEP: GLenum = 0x1E00;\nexport const REPLACE: GLenum = 0x1E01;\nexport const INCR: GLenum = 0x1E02;\nexport const DECR: GLenum = 0x1E03;\nexport const INVERT: GLenum = 0x150A;\nexport const INCR_WRAP: GLenum = 0x8507;\nexport const DECR_WRAP: GLenum = 0x8508;\n\n/* StringName */\nexport const VENDOR: GLenum = 0x1F00;\nexport const RENDERER: GLenum = 0x1F01;\nexport const VERSION: GLenum = 0x1F02;\n\n/* TextureMagFilter */\nexport const NEAREST: GLenum = 0x2600;\nexport const LINEAR: GLenum = 0x2601;\n\n/* TextureMinFilter */\n/*      NEAREST */\n/*      LINEAR */\nexport const NEAREST_MIPMAP_NEAREST: GLenum = 0x2700;\nexport const LINEAR_MIPMAP_NEAREST: GLenum = 0x2701;\nexport const NEAREST_MIPMAP_LINEAR: GLenum = 0x2702;\nexport const LINEAR_MIPMAP_LINEAR: GLenum = 0x2703;\n\n/* TextureParameterName */\nexport const TEXTURE_MAG_FILTER: GLenum = 0x2800;\nexport const TEXTURE_MIN_FILTER: GLenum = 0x2801;\nexport const TEXTURE_WRAP_S: GLenum = 0x2802;\nexport const TEXTURE_WRAP_T: GLenum = 0x2803;\n\n/* TextureTarget */\nexport const TEXTURE_2D: GLenum = 0x0DE1;\nexport const TEXTURE: GLenum = 0x1702;\n\nexport const TEXTURE_CUBE_MAP: GLenum = 0x8513;\nexport const TEXTURE_BINDING_CUBE_MAP: GLenum = 0x8514;\nexport const TEXTURE_CUBE_MAP_POSITIVE_X: GLenum = 0x8515;\nexport const TEXTURE_CUBE_MAP_NEGATIVE_X: GLenum = 0x8516;\nexport const TEXTURE_CUBE_MAP_POSITIVE_Y: GLenum = 0x8517;\nexport const TEXTURE_CUBE_MAP_NEGATIVE_Y: GLenum = 0x8518;\nexport const TEXTURE_CUBE_MAP_POSITIVE_Z: GLenum = 0x8519;\nexport const TEXTURE_CUBE_MAP_NEGATIVE_Z: GLenum = 0x851A;\nexport const MAX_CUBE_MAP_TEXTURE_SIZE: GLenum = 0x851C;\n\n/* TextureUnit */\nexport const TEXTURE0: GLenum = 0x84C0;\nexport const TEXTURE1: GLenum = 0x84C1;\nexport const TEXTURE2: GLenum = 0x84C2;\nexport const TEXTURE3: GLenum = 0x84C3;\nexport const TEXTURE4: GLenum = 0x84C4;\nexport const TEXTURE5: GLenum = 0x84C5;\nexport const TEXTURE6: GLenum = 0x84C6;\nexport const TEXTURE7: GLenum = 0x84C7;\nexport const TEXTURE8: GLenum = 0x84C8;\nexport const TEXTURE9: GLenum = 0x84C9;\nexport const TEXTURE10: GLenum = 0x84CA;\nexport const TEXTURE11: GLenum = 0x84CB;\nexport const TEXTURE12: GLenum = 0x84CC;\nexport const TEXTURE13: GLenum = 0x84CD;\nexport const TEXTURE14: GLenum = 0x84CE;\nexport const TEXTURE15: GLenum = 0x84CF;\nexport const TEXTURE16: GLenum = 0x84D0;\nexport const TEXTURE17: GLenum = 0x84D1;\nexport const TEXTURE18: GLenum = 0x84D2;\nexport const TEXTURE19: GLenum = 0x84D3;\nexport const TEXTURE20: GLenum = 0x84D4;\nexport const TEXTURE21: GLenum = 0x84D5;\nexport const TEXTURE22: GLenum = 0x84D6;\nexport const TEXTURE23: GLenum = 0x84D7;\nexport const TEXTURE24: GLenum = 0x84D8;\nexport const TEXTURE25: GLenum = 0x84D9;\nexport const TEXTURE26: GLenum = 0x84DA;\nexport const TEXTURE27: GLenum = 0x84DB;\nexport const TEXTURE28: GLenum = 0x84DC;\nexport const TEXTURE29: GLenum = 0x84DD;\nexport const TEXTURE30: GLenum = 0x84DE;\nexport const TEXTURE31: GLenum = 0x84DF;\nexport const ACTIVE_TEXTURE: GLenum = 0x84E0;\n\n/* TextureWrapMode */\nexport const REPEAT: GLenum = 0x2901;\nexport const CLAMP_TO_EDGE: GLenum = 0x812F;\nexport const MIRRORED_REPEAT: GLenum = 0x8370;\n\n/* Uniform Types */\nexport const FLOAT_VEC2: GLenum = 0x8B50;\nexport const FLOAT_VEC3: GLenum = 0x8B51;\nexport const FLOAT_VEC4: GLenum = 0x8B52;\nexport const INT_VEC2: GLenum = 0x8B53;\nexport const INT_VEC3: GLenum = 0x8B54;\nexport const INT_VEC4: GLenum = 0x8B55;\nexport const BOOL: GLenum = 0x8B56;\nexport const BOOL_VEC2: GLenum = 0x8B57;\nexport const BOOL_VEC3: GLenum = 0x8B58;\nexport const BOOL_VEC4: GLenum = 0x8B59;\nexport const FLOAT_MAT2: GLenum = 0x8B5A;\nexport const FLOAT_MAT3: GLenum = 0x8B5B;\nexport const FLOAT_MAT4: GLenum = 0x8B5C;\nexport const SAMPLER_2D: GLenum = 0x8B5E;\nexport const SAMPLER_CUBE: GLenum = 0x8B60;\n\n/* Vertex Arrays */\nexport const VERTEX_ATTRIB_ARRAY_ENABLED: GLenum = 0x8622;\nexport const VERTEX_ATTRIB_ARRAY_SIZE: GLenum = 0x8623;\nexport const VERTEX_ATTRIB_ARRAY_STRIDE: GLenum = 0x8624;\nexport const VERTEX_ATTRIB_ARRAY_TYPE: GLenum = 0x8625;\nexport const VERTEX_ATTRIB_ARRAY_NORMALIZED: GLenum = 0x886A;\nexport const VERTEX_ATTRIB_ARRAY_POINTER: GLenum = 0x8645;\nexport const VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: GLenum = 0x889F;\n\n/* Shader Source */\nexport const COMPILE_STATUS: GLenum = 0x8B81;\n\n/* Shader Precision-Specified Types */\nexport const LOW_FLOAT: GLenum = 0x8DF0;\nexport const MEDIUM_FLOAT: GLenum = 0x8DF1;\nexport const HIGH_FLOAT: GLenum = 0x8DF2;\nexport const LOW_INT: GLenum = 0x8DF3;\nexport const MEDIUM_INT: GLenum = 0x8DF4;\nexport const HIGH_INT: GLenum = 0x8DF5;\n\n/* Framebuffer Object. */\nexport const FRAMEBUFFER: GLenum = 0x8D40;\nexport const RENDERBUFFER: GLenum = 0x8D41;\n\nexport const RGBA4: GLenum = 0x8056;\nexport const RGB5_A1: GLenum = 0x8057;\nexport const RGB565: GLenum = 0x8D62;\nexport const DEPTH_COMPONENT16: GLenum = 0x81A5;\nexport const STENCIL_INDEX: GLenum = 0x1901;\nexport const STENCIL_INDEX8: GLenum = 0x8D48;\nexport const DEPTH_STENCIL: GLenum = 0x84F9;\n\nexport const RENDERBUFFER_WIDTH: GLenum = 0x8D42;\nexport const RENDERBUFFER_HEIGHT: GLenum = 0x8D43;\nexport const RENDERBUFFER_INTERNAL_FORMAT: GLenum = 0x8D44;\nexport const RENDERBUFFER_RED_SIZE: GLenum = 0x8D50;\nexport const RENDERBUFFER_GREEN_SIZE: GLenum = 0x8D51;\nexport const RENDERBUFFER_BLUE_SIZE: GLenum = 0x8D52;\nexport const RENDERBUFFER_ALPHA_SIZE: GLenum = 0x8D53;\nexport const RENDERBUFFER_DEPTH_SIZE: GLenum = 0x8D54;\nexport const RENDERBUFFER_STENCIL_SIZE: GLenum = 0x8D55;\n\nexport const FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: GLenum = 0x8CD0;\nexport const FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: GLenum = 0x8CD1;\nexport const FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: GLenum = 0x8CD2;\nexport const FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: GLenum = 0x8CD3;\n\nexport const COLOR_ATTACHMENT0: GLenum = 0x8CE0;\nexport const DEPTH_ATTACHMENT: GLenum = 0x8D00;\nexport const STENCIL_ATTACHMENT: GLenum = 0x8D20;\nexport const DEPTH_STENCIL_ATTACHMENT: GLenum = 0x821A;\n\nexport const NONE: GLenum = 0;\n\nexport const FRAMEBUFFER_COMPLETE: GLenum = 0x8CD5;\nexport const FRAMEBUFFER_INCOMPLETE_ATTACHMENT: GLenum = 0x8CD6;\nexport const FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: GLenum = 0x8CD7;\nexport const FRAMEBUFFER_INCOMPLETE_DIMENSIONS: GLenum = 0x8CD9;\nexport const FRAMEBUFFER_UNSUPPORTED: GLenum = 0x8CDD;\n\nexport const FRAMEBUFFER_BINDING: GLenum = 0x8CA6;\nexport const RENDERBUFFER_BINDING: GLenum = 0x8CA7;\nexport const MAX_RENDERBUFFER_SIZE: GLenum = 0x84E8;\n\nexport const INVALID_FRAMEBUFFER_OPERATION: GLenum = 0x0506;\n\n/* WebGL-specific enums */\nexport const UNPACK_FLIP_Y_WEBGL: GLenum = 0x9240;\nexport const UNPACK_PREMULTIPLY_ALPHA_WEBGL: GLenum = 0x9241;\nexport const CONTEXT_LOST_WEBGL: GLenum = 0x9242;\nexport const UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;\nexport const BROWSER_DEFAULT_WEBGL: GLenum = 0x9244;\n\n//type HTMLCanvasElement = externref;\n\n//export declare function getCanvas(gl: WebGLRenderingContextId): HTMLCanvasElement;\nexport declare function getDrawingBufferWidth(gl: WebGLRenderingContextId): GLsizei;\nexport declare function getDrawingBufferHeight(gl: WebGLRenderingContextId): GLsizei;\n\nexport declare function getContextAttributes(gl: WebGLRenderingContextId): WebGLContextAttributes;\nexport declare function isContextLost(gl: WebGLRenderingContextId): bool;\n\ntype sequence<T> = externref;\n\nexport declare function getSupportedExtensions(gl: WebGLRenderingContextId): sequence<string>;\n\ntype object_ = externref;\n\nexport declare function getExtension(gl: WebGLRenderingContextId, name: string): object_;\n\n// THIS WILL BE IN INDEX INTO A PROGRAM LIST KEPT IN THE JS\nexport type WebGLProgram = i32; //externref;\nexport type WebGLShader = i32;\nexport type WebGLBuffer = i32;\nexport type WebGLFramebuffer = i32;\nexport type WebGLRenderbuffer = i32;\nexport type WebGLTexture = i32;\n\nexport declare function activeTexture(gl: WebGLRenderingContextId, texture: GLenum): void;\nexport declare function createContextFromCanvas(canvas_id: string, context_type: string): WebGLRenderingContextId;\nexport declare function attachShader(gl: WebGLRenderingContextId, program: WebGLProgram, shader: WebGLShader): void;\n// export declare function bindAttribLocation(gl: WebGLRenderingContextId, program: WebGLProgram, index: GLuint, name: string): void;\nexport declare function bindBuffer(gl: WebGLRenderingContextId, target: GLenum, buffer: WebGLBuffer): void;\nexport declare function bindFramebuffer(gl: WebGLRenderingContextId, target: GLenum, framebuffer: WebGLFramebuffer): void;\nexport declare function bindRenderbuffer(gl: WebGLRenderingContextId, target: GLenum, renderbuffer: WebGLRenderbuffer): void;\nexport declare function bindTexture(gl: WebGLRenderingContextId, target: GLenum, texture: WebGLTexture): void;\nexport declare function blendColor(gl: WebGLRenderingContextId, red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf): void;\nexport declare function blendEquation(gl: WebGLRenderingContextId, mode: GLenum): void;\nexport declare function blendEquationSeparate(gl: WebGLRenderingContextId, modeRGB: GLenum, modeAlpha: GLenum): void;\nexport declare function blendFunc(gl: WebGLRenderingContextId, sfactor: GLenum, dfactor: GLenum): void;\nexport declare function blendFuncSeparate(gl: WebGLRenderingContextId, srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum): void;\nexport declare function bufferData<T>(gl: WebGLRenderingContextId, target: GLenum, data: StaticArray<T>, usage: GLenum): void;\nexport declare function bufferSubData<T>(gl: WebGLRenderingContextId, target: GLenum, offset: GLintptr, data: Array<T>): void;\n\nexport declare function checkFramebufferStatus(gl: WebGLRenderingContextId, target: GLenum): GLenum;\nexport declare function clear(gl: WebGLRenderingContextId, mask: GLbitfield): void;\nexport declare function clearColor(gl: WebGLRenderingContextId, red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf): void;\nexport declare function clearDepth(gl: WebGLRenderingContextId, depth: GLclampf): void;\nexport declare function clearStencil(gl: WebGLRenderingContextId, s: GLint): void;\nexport declare function colorMask(gl: WebGLRenderingContextId, red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean): void;\nexport declare function compileShader(gl: WebGLRenderingContextId, shader: WebGLShader): void;\n\nexport declare function compressedTexImage2D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, data: ArrayBufferView): void;\nexport declare function compressedTexSubImage2D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, data: ArrayBufferView): void;\n\nexport declare function copyTexImage2D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint): void;\nexport declare function copyTexSubImage2D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;\n\nexport declare function createBuffer(gl: WebGLRenderingContextId): WebGLBuffer;\nexport declare function createFramebuffer(gl: WebGLRenderingContextId): WebGLFramebuffer;\nexport declare function createProgram(gl: WebGLRenderingContextId): WebGLProgram;\nexport declare function createRenderbuffer(gl: WebGLRenderingContextId): WebGLRenderbuffer;\nexport declare function createShader(gl: WebGLRenderingContextId, typ: GLenum): WebGLShader;\nexport declare function createTexture(gl: WebGLRenderingContextId): WebGLTexture;\n\nexport declare function cullFace(gl: WebGLRenderingContextId, mode: GLenum): void;\n//...\n\nexport declare function deleteBuffer(gl: WebGLRenderingContextId, buffer: WebGLBuffer): void;\nexport declare function deleteFramebuffer(gl: WebGLRenderingContextId, framebuffer: WebGLFramebuffer): void;\nexport declare function deleteProgram(gl: WebGLRenderingContextId, program: WebGLProgram): void;\nexport declare function deleteRenderbuffer(gl: WebGLRenderingContextId, renderbuffer: WebGLRenderbuffer): void;\nexport declare function deleteShader(gl: WebGLRenderingContextId, shader: WebGLShader): void;\nexport declare function deleteTexture(gl: WebGLRenderingContextId, texture: WebGLTexture): void;\n\nexport declare function depthFunc(gl: WebGLRenderingContextId, func: GLenum): void;\nexport declare function depthMask(gl: WebGLRenderingContextId, flag: GLboolean): void;\nexport declare function depthRange(gl: WebGLRenderingContextId, zNear: GLclampf, zFar: GLclampf): void;\nexport declare function detachShader(gl: WebGLRenderingContextId, program: WebGLProgram, shader: WebGLShader): void;\nexport declare function disable(gl: WebGLRenderingContextId, cap: GLenum): void;\nexport declare function disableVertexAttribArray(gl: WebGLRenderingContextId, index: GLuint): void;\nexport declare function drawArrays(gl: WebGLRenderingContextId, mode: GLenum, first: GLint, count: GLsizei): void;\nexport declare function drawElements(gl: WebGLRenderingContextId, mode: GLenum, count: GLsizei, typ: GLenum, offset: GLintptr): void;\n\nexport declare function enable(gl: WebGLRenderingContextId, cap: GLenum): void;\nexport declare function enableVertexAttribArray(gl: WebGLRenderingContextId, index: GLuint): void;\nexport declare function finish(gl: WebGLRenderingContextId): void;\nexport declare function flush(gl: WebGLRenderingContextId): void;\nexport declare function framebufferRenderbuffer(gl: WebGLRenderingContextId, target: GLenum, attachment: GLenum,\n\trenderbuffertarget: GLenum,\n\trenderbuffer: WebGLRenderbuffer): void;\nexport declare function framebufferTexture2D(gl: WebGLRenderingContextId, target: GLenum, attachment: GLenum, textarget: GLenum,\n\ttexture: WebGLTexture, level: GLint): void;\nexport declare function frontFace(gl: WebGLRenderingContextId, mode: GLenum): void;\n\nexport declare function generateMipmap(gl: WebGLRenderingContextId, target: GLenum): void;\n\nexport declare function getActiveAttrib(gl: WebGLRenderingContextId, program: WebGLProgram, index: GLuint): WebGLActiveInfo;\nexport declare function getActiveUniform(gl: WebGLRenderingContextId, program: WebGLProgram, index: GLuint): WebGLActiveInfo;\nexport declare function getAttachedShaders(gl: WebGLRenderingContextId, program: WebGLProgram): sequence<WebGLShader>;\n\nexport declare function getAttribLocation(gl: WebGLRenderingContextId, program: WebGLProgram, name: string): GLint;\n\nexport declare function getBufferParameter(gl: WebGLRenderingContextId, target: GLenum, pname: GLenum): externref; // any\nexport declare function getParameter(gl: WebGLRenderingContextId, pname: GLenum): externref; // any\n\nexport declare function getError(gl: WebGLRenderingContextId): GLenum;\n\nexport declare function getFramebufferAttachmentParameter(gl: WebGLRenderingContextId, target: GLenum, attachment: GLenum,\n\tpname: GLenum): externref; // any\nexport declare function getProgramParameter(gl: WebGLRenderingContextId, program: WebGLProgram, pname: GLenum): bool; // any\nexport declare function getProgramInfoLog(gl: WebGLRenderingContextId, program: WebGLProgram): DOMString;\nexport declare function getRenderbufferParameter(gl: WebGLRenderingContextId, target: GLenum, pname: GLenum): externref; // any\nexport declare function getShaderParameter(gl: WebGLRenderingContextId, shader: WebGLShader, pname: GLenum): bool; // any\nexport declare function getShaderPrecisionFormat(gl: WebGLRenderingContextId, shadertype: GLenum, precisiontype: GLenum): WebGLShaderPrecisionFormat;\nexport declare function getShaderInfoLog(gl: WebGLRenderingContextId, shader: WebGLShader): DOMString;\n\nexport declare function getShaderSource(gl: WebGLRenderingContextId, shader: WebGLShader): DOMString;\n\nexport declare function getTexParameter(gl: WebGLRenderingContextId, target: GLenum, pname: GLenum): externref; // any\n\nexport declare function getUniform(gl: WebGLRenderingContextId, program: WebGLProgram, location: WebGLUniformLocation): externref; // any\n\nexport declare function getUniformLocation(gl: WebGLRenderingContextId, program: WebGLProgram, name: string): WebGLUniformLocation;\n\nexport declare function getVertexAttrib(gl: WebGLRenderingContextId, index: GLuint, pname: GLenum): externref; // any\n\nexport declare function getVertexAttribOffset(gl: WebGLRenderingContextId, index: GLuint, pname: GLenum): GLsizeiptr;\n\nexport declare function hint(gl: WebGLRenderingContextId, target: GLenum, mode: GLenum): void;\nexport declare function isBuffer(gl: WebGLRenderingContextId, buffer: WebGLBuffer): GLboolean;\nexport declare function isEnabled(gl: WebGLRenderingContextId, cap: GLenum): GLboolean;\nexport declare function isFramebuffer(gl: WebGLRenderingContextId, framebuffer: WebGLFramebuffer): GLboolean;\nexport declare function isProgram(gl: WebGLRenderingContextId, program: WebGLProgram): GLboolean;\nexport declare function isRenderbuffer(gl: WebGLRenderingContextId, renderbuffer: WebGLRenderbuffer): GLboolean;\nexport declare function isShader(gl: WebGLRenderingContextId, shader: WebGLShader): GLboolean;\nexport declare function isTexture(gl: WebGLRenderingContextId, texture: WebGLTexture): GLboolean;\nexport declare function lineWidth(gl: WebGLRenderingContextId, width: GLfloat): void;\nexport declare function linkProgram(gl: WebGLRenderingContextId, program: WebGLProgram): void;\nexport declare function pixelStorei(gl: WebGLRenderingContextId, pname: GLenum, param: GLint): void;\nexport declare function polygonOffset(gl: WebGLRenderingContextId, factor: GLfloat, units: GLfloat): void;\n\nexport declare function readPixels(gl: WebGLRenderingContextId, x: GLint, y: GLint, width: GLsizei, height: GLsizei,\n\tformat: GLenum, typ: GLenum, pixels: ArrayBufferView): void;\n\nexport declare function renderbufferStorage(gl: WebGLRenderingContextId, target: GLenum, internalformat: GLenum,\n\twidth: GLsizei, height: GLsizei): void;\nexport declare function sampleCoverage(gl: WebGLRenderingContextId, value: GLclampf, invert: GLboolean): void;\nexport declare function scissor(gl: WebGLRenderingContextId, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;\n\nexport declare function shaderSource(gl: WebGLRenderingContextId, shader: WebGLShader, source: string): void;\n\nexport declare function stencilFunc(gl: WebGLRenderingContextId, func: GLenum, ref: GLint, mask: GLuint): void;\nexport declare function stencilFuncSeparate(gl: WebGLRenderingContextId, face: GLenum, func: GLenum, ref: GLint, mask: GLuint): void;\nexport declare function stencilMask(gl: WebGLRenderingContextId, mask: GLuint): void;\nexport declare function stencilMaskSeparate(gl: WebGLRenderingContextId, face: GLenum, mask: GLuint): void;\nexport declare function stencilOp(gl: WebGLRenderingContextId, fail: GLenum, zfail: GLenum, zpass: GLenum): void;\nexport declare function stencilOpSeparate(gl: WebGLRenderingContextId, face: GLenum, fail: GLenum, zfail: GLenum, zpass: GLenum): void;\n\nexport declare function texImage2D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, internalformat: GLenum,\n\tformat: GLenum, typ: GLenum, image: ImageData): void;\n\nexport declare function texParameterf(gl: WebGLRenderingContextId, target: GLenum, pname: GLenum, param: GLfloat): void;\nexport declare function texParameteri(gl: WebGLRenderingContextId, target: GLenum, pname: GLenum, param: GLint): void;\n\nexport declare function texSubImage2D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint,\n\tformat: GLenum, typ: GLenum, pixels: ImageData): void;\n\nexport declare function uniform1f(gl: WebGLRenderingContextId, location: WebGLUniformLocation, x: GLfloat): void;\nexport declare function uniform1fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v: StaticArray<GLfloat>/*Float32Array*/): void;\n\nexport declare function uniform1i(gl: WebGLRenderingContextId, location: WebGLUniformLocation, x: GLint): void;\nexport declare function uniform1iv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v: StaticArray<GLint>/*Int32Array*/): void;\n\nexport declare function uniform2f(gl: WebGLRenderingContextId, location: WebGLUniformLocation, x: GLfloat, y: GLfloat): void;\nexport declare function uniform2fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v: StaticArray<GLfloat>/*Float32Array*/): void;\n\nexport declare function uniform2i(gl: WebGLRenderingContextId, location: WebGLUniformLocation, x: GLint, y: GLint): void;\nexport declare function uniform2iv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v: StaticArray<GLint> /*Int32Array*/): void;\n\nexport declare function uniform3f(gl: WebGLRenderingContextId, location: WebGLUniformLocation, x: GLfloat, y: GLfloat, z: GLfloat): void;\nexport declare function uniform3fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v: StaticArray<GLfloat>/*Float32Array*/): void;\n\nexport declare function uniform3i(gl: WebGLRenderingContextId, location: WebGLUniformLocation, x: GLint, y: GLint, z: GLint): void;\nexport declare function uniform3iv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v: StaticArray<GLint>/*Int32Array*/): void;\n\nexport declare function uniform4f(gl: WebGLRenderingContextId, location: WebGLUniformLocation, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat): void;\nexport declare function uniform4fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v: StaticArray<GLfloat>/*JSFloat32Array*/): void;\n\nexport declare function uniform4i(gl: WebGLRenderingContextId, location: WebGLUniformLocation, x: GLint, y: GLint, z: GLint, w: GLint): void;\nexport declare function uniform4iv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v: StaticArray<GLint>/*JSInt32Array*/): void;\n\nexport declare function uniformMatrix2fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean,\n\tvalue: StaticArray<GLfloat>): void;\n/*\nexport declare function uniformMatrix2fv( gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean,\n\tvalue: sequence<GLfloat>): void;\n*/\nexport declare function uniformMatrix3fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean,\n\tvalue: StaticArray<GLfloat>): void;\n/*\nexport declare function uniformMatrix3fv( gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean,\n\tvalue: sequence<GLfloat>): void;\n*/\nexport declare function uniformMatrix4fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean,\n\tvalue: StaticArray<GLfloat>): void;\n/*\nexport declare function uniformMatrix4fv( gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean,\n\tvalue: sequence<GLfloat>): void;\n*/\nexport declare function useProgram(gl: WebGLRenderingContextId, program: WebGLProgram): void;\nexport declare function validateProgram(gl: WebGLRenderingContextId, program: WebGLProgram): void;\n\nexport declare function vertexAttrib1f(gl: WebGLRenderingContextId, indx: GLuint, x: GLfloat): void;\nexport declare function vertexAttrib1fv(gl: WebGLRenderingContextId, indx: GLuint, values: StaticArray<GLfloat>): void;\n\nexport declare function vertexAttrib2f(gl: WebGLRenderingContextId, indx: GLuint, x: GLfloat, y: GLfloat): void;\nexport declare function vertexAttrib2fv(gl: WebGLRenderingContextId, indx: GLuint, values: StaticArray<GLfloat>): void;\n\nexport declare function vertexAttrib3f(gl: WebGLRenderingContextId, indx: GLuint, x: GLfloat, y: GLfloat, z: GLfloat): void;\nexport declare function vertexAttrib3fv(gl: WebGLRenderingContextId, indx: GLuint, values: StaticArray<GLfloat>): void;\n\nexport declare function vertexAttrib4f(gl: WebGLRenderingContextId, indx: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat): void;\nexport declare function vertexAttrib4fv(gl: WebGLRenderingContextId, indx: GLuint, values: StaticArray<GLfloat>): void;\n\nexport declare function vertexAttribPointer(gl: WebGLRenderingContextId, indx: GLint, size: GLint, typ: GLenum,\n\tnormalized: /*GLboolean*/GLint, stride: GLsizei, offset: GLintptr): void;\n\nexport declare function viewport(gl: WebGLRenderingContextId, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;\n\n// ... WEBGL 2 ...\n/* Buffer objects */\nexport declare function copyBufferSubData(gl: WebGLRenderingContextId, readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr,\n\twriteOffset: GLintptr, size: GLsizeiptr): void;\n\n// @ts-ignore\nexport declare function getBufferSubData(gl: WebGLRenderingContextId, target: GLenum, srcByteOffset: GLintptr, /*[AllowShared]*/ dstBuffer: ArrayBufferView, dstOffset: GLuint = 0, length: GLuint = 0): void;\n\n/* Framebuffer objects */\nexport declare function blitFramebuffer(gl: WebGLRenderingContextId, srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint,\n\tdstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum): void;\nexport declare function framebufferTextureLayer(gl: WebGLRenderingContextId, target: GLenum, attachment: GLenum, texture: WebGLTexture, level: GLint,\n\tlayer: GLint): void;\nexport declare function invalidateFramebuffer(gl: WebGLRenderingContextId, target: GLenum, attachments: sequence<GLenum>): void;\nexport declare function invalidateSubFramebuffer(gl: WebGLRenderingContextId, target: GLenum, attachments: sequence<GLenum>,\n\tx: GLint, y: GLint, width: GLsizei, height: GLsizei): void;\nexport declare function readBuffer(gl: WebGLRenderingContextId, src: GLenum): void;\n\n/* Renderbuffer objects */\nexport declare function getInternalformatParameter(gl: WebGLRenderingContextId, target: GLenum, internalformat: GLenum, pname: GLenum): externref; // any\nexport declare function renderbufferStorageMultisample(gl: WebGLRenderingContextId, target: GLenum, samples: GLsizei, internalformat: GLenum,\n\twidth: GLsizei, height: GLsizei): void;\n\n/* Texture objects */\nexport declare function texStorage2D(gl: WebGLRenderingContextId, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei,\n\theight: GLsizei): void;\nexport declare function texStorage3D(gl: WebGLRenderingContextId, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei,\n\theight: GLsizei, depth: GLsizei): void;\n\nexport declare function texImage3D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei,\n\tdepth: GLsizei, border: GLint, format: GLenum, typ: GLenum, pboOffset: GLintptr): void;\n\nexport declare function texSubImage3D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint,\n\twidth: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, typ: GLenum,\n\tpboOffset: GLintptr): void;\n\nexport declare function copyTexSubImage3D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint,\n\tx: GLint, y: GLint, width: GLsizei, height: GLsizei): void;\n\nexport declare function compressedTexImage3D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei,\n\theight: GLsizei, depth: GLsizei, border: GLint, imageSize: GLsizei, offset: GLintptr): void;\n\nexport declare function compressedTexSubImage3D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint,\n\tzoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei,\n\tformat: GLenum, imageSize: GLsizei, offset: GLintptr): void;\n\n/* Programs and shaders */\nexport declare function getFragDataLocation(gl: WebGLRenderingContextId, program: WebGLProgram, name: DOMString): GLint;\n\n/* Uniforms */\nexport declare function uniform1ui(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v0: GLuint): void;\nexport declare function uniform2ui(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v0: GLuint, v1: GLuint): void;\nexport declare function uniform3ui(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v0: GLuint, v1: GLuint, v2: GLuint): void;\nexport declare function uniform4ui(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint): void;\n\n// @ts-ignore\nexport declare function uniform1uiv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void;\n// @ts-ignore\nexport declare function uniform2uiv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void;\n// @ts-ignore\nexport declare function uniform3uiv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void;\n// @ts-ignore\nexport declare function uniform4uiv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void;\n// @ts-ignore\nexport declare function uniformMatrix3x2fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void;\n// @ts-ignore\nexport declare function uniformMatrix4x2fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void;\n\n// @ts-ignore\nexport declare function uniformMatrix2x3fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void;\n// @ts-ignore\nexport declare function uniformMatrix4x3fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void;\n\n// @ts-ignore\nexport declare function uniformMatrix2x4fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void;\n// @ts-ignore\nexport declare function uniformMatrix3x4fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void;\n\n/* Vertex attribs */\nexport declare function vertexAttribI4i(gl: WebGLRenderingContextId, index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint): void;\nexport declare function vertexAttribI4iv(gl: WebGLRenderingContextId, index: GLuint, values: Int32List): void;\nexport declare function vertexAttribI4ui(gl: WebGLRenderingContextId, index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint): void;\nexport declare function vertexAttribI4uiv(gl: WebGLRenderingContextId, index: GLuint, values: Uint32List): void;\nexport declare function vertexAttribIPointer(gl: WebGLRenderingContextId, index: GLuint, size: GLint, typ: GLenum, stride: GLsizei, offset: GLintptr): void;\n\n/* Writing to the drawing buffer */\nexport declare function vertexAttribDivisor(gl: WebGLRenderingContextId, index: GLuint, divisor: GLuint): void;\nexport declare function drawArraysInstanced(gl: WebGLRenderingContextId, mode: GLenum, first: GLint, count: GLsizei, instanceCount: GLsizei): void;\nexport declare function drawElementsInstanced(gl: WebGLRenderingContextId, mode: GLenum, count: GLsizei, typ: GLenum, offset: GLintptr, instanceCount: GLsizei): void;\nexport declare function drawRangeElements(gl: WebGLRenderingContextId, mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, typ: GLenum, offset: GLintptr): void;\n\n/* Multiple Render Targets */\nexport declare function drawBuffers(gl: WebGLRenderingContextId, buffers: sequence<GLenum>): void;\n\n// @ts-ignore\nexport declare function clearBufferfv(gl: WebGLRenderingContextId, buffer: GLenum, drawbuffer: GLint, values: Float32List, srcOffset: GLuint = 0): void;\n// @ts-ignore\nexport declare function clearBufferiv(gl: WebGLRenderingContextId, buffer: GLenum, drawbuffer: GLint, values: Int32List, srcOffset: GLuint = 0): void;\n// @ts-ignore\nexport declare function clearBufferuiv(gl: WebGLRenderingContextId, buffer: GLenum, drawbuffer: GLint, values: Uint32List, srcOffset: GLuint = 0): void;\n\nexport declare function clearBufferfi(gl: WebGLRenderingContextId, buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint): void;\n\n/* Query Objects */\nexport declare function createQuery(gl: WebGLRenderingContextId): WebGLQuery;\nexport declare function deleteQuery(gl: WebGLRenderingContextId, query: WebGLQuery): void;\n/*[WebGLHandlesContextLoss]*/\nexport declare function isQuery(gl: WebGLRenderingContextId, query: WebGLQuery): GLboolean;\nexport declare function beginQuery(gl: WebGLRenderingContextId, target: GLenum, query: WebGLQuery): void;\nexport declare function endQuery(gl: WebGLRenderingContextId, target: GLenum): void;\nexport declare function getQuery(gl: WebGLRenderingContextId, target: GLenum, pname: GLenum): WebGLQuery;\nexport declare function getQueryParameter(gl: WebGLRenderingContextId, query: WebGLQuery, pname: GLenum): externref; // any\n\n/* Sampler Objects */\nexport declare function createSampler(gl: WebGLRenderingContextId): WebGLSampler;\nexport declare function deleteSampler(gl: WebGLRenderingContextId, sampler: WebGLSampler): void;\n/*[WebGLHandlesContextLoss]*/\nexport declare function isSampler(gl: WebGLRenderingContextId, sampler: WebGLSampler): GLboolean;\nexport declare function bindSampler(gl: WebGLRenderingContextId, unit: GLuint, sampler: WebGLSampler): void;\nexport declare function samplerParameteri(gl: WebGLRenderingContextId, sampler: WebGLSampler, pname: GLenum, param: GLint): void;\nexport declare function samplerParameterf(gl: WebGLRenderingContextId, sampler: WebGLSampler, pname: GLenum, param: GLfloat): void;\nexport declare function getSamplerParameter(gl: WebGLRenderingContextId, sampler: WebGLSampler, pname: GLenum): externref; // any\n\n/* Sync objects */\nexport declare function fenceSync(gl: WebGLRenderingContextId, condition: GLenum, flags: GLbitfield): WebGLSync;\n/*[WebGLHandlesContextLoss]*/\nexport declare function isSync(gl: WebGLRenderingContextId, sync: WebGLSync): GLboolean;\nexport declare function deleteSync(gl: WebGLRenderingContextId, sync: WebGLSync): void;\nexport declare function clientWaitSync(gl: WebGLRenderingContextId, sync: WebGLSync, flags: GLbitfield, timeout: GLuint64): GLenum;\nexport declare function waitSync(gl: WebGLRenderingContextId, sync: WebGLSync, flags: GLbitfield, timeout: GLint64): void;\nexport declare function getSyncParameter(gl: WebGLRenderingContextId, sync: WebGLSync, pname: GLenum): externref; // any\n\n/* Transform Feedback */\nexport declare function createTransformFeedback(gl: WebGLRenderingContextId): WebGLTransformFeedback;\nexport declare function deleteTransformFeedback(gl: WebGLRenderingContextId, tf: WebGLTransformFeedback): void;\n/*[WebGLHandlesContextLoss]*/\nexport declare function isTransformFeedback(gl: WebGLRenderingContextId, tf: WebGLTransformFeedback): GLboolean;\nexport declare function bindTransformFeedback(gl: WebGLRenderingContextId, target: GLenum, tf: WebGLTransformFeedback): void;\nexport declare function beginTransformFeedback(gl: WebGLRenderingContextId, primitiveMode: GLenum): void;\nexport declare function endTransformFeedback(gl: WebGLRenderingContextId): void;\nexport declare function transformFeedbackVaryings(gl: WebGLRenderingContextId, program: WebGLProgram, varyings: sequence<DOMString>, bufferMode: GLenum): void;\nexport declare function getTransformFeedbackVarying(gl: WebGLRenderingContextId, program: WebGLProgram, index: GLuint): WebGLActiveInfo;\nexport declare function pauseTransformFeedback(gl: WebGLRenderingContextId): void;\nexport declare function resumeTransformFeedback(gl: WebGLRenderingContextId): void;\n\n/* Uniform Buffer Objects and Transform Feedback Buffers */\nexport declare function bindBufferBase(gl: WebGLRenderingContextId, target: GLenum, index: GLuint, buffer: WebGLBuffer): void;\nexport declare function bindBufferRange(gl: WebGLRenderingContextId, target: GLenum, index: GLuint, buffer: WebGLBuffer, offset: GLintptr, size: GLsizeiptr): void;\nexport declare function getIndexedParameter(gl: WebGLRenderingContextId, target: GLenum, index: GLuint): externref; // any\nexport declare function getUniformIndices(gl: WebGLRenderingContextId, program: WebGLProgram, uniformNames: sequence<DOMString>): sequence<GLuint>;\nexport declare function getActiveUniforms(gl: WebGLRenderingContextId, program: WebGLProgram, uniformIndices: sequence<GLuint>, pname: GLenum): externref; // any\nexport declare function getUniformBlockIndex(gl: WebGLRenderingContextId, program: WebGLProgram, uniformBlockName: DOMString): GLuint;\nexport declare function getActiveUniformBlockParameter(gl: WebGLRenderingContextId, program: WebGLProgram, uniformBlockIndex: GLuint, pname: GLenum): externref; // any\nexport declare function getActiveUniformBlockName(gl: WebGLRenderingContextId, program: WebGLProgram, uniformBlockIndex: GLuint): DOMString;\nexport declare function uniformBlockBinding(gl: WebGLRenderingContextId, program: WebGLProgram, uniformBlockIndex: GLuint, uniformBlockBinding: GLuint): void;\n\n/* Vertex Array Objects */\nexport declare function createVertexArray(gl: WebGLRenderingContextId): WebGLVertexArrayObject;\nexport declare function deleteVertexArray(gl: WebGLRenderingContextId, vertexArray: WebGLVertexArrayObject): void;\n/*[WebGLHandlesContextLoss]*/\nexport declare function isVertexArray(gl: WebGLRenderingContextId, vertexArray: WebGLVertexArrayObject): GLboolean;\nexport declare function bindVertexArray(gl: WebGLRenderingContextId, array: WebGLVertexArrayObject): void;\n\n\n@final @unmanaged\nexport class WebGLRenderingContext {\n\tgl_id: WebGLRenderingContextId;\n\n\t@inline constructor(canvas_id: string, context_type: string) {\n\t\t// constructor needs to create the gl_id\n\t\tthis.gl_id = createContextFromCanvas(canvas_id, context_type);\n\t}\n\n\t/*\n\t@inline get ptr(): usize {\n\t\treturn changetype<usize>(this);\n\t}\n\t*/\n\n\t@inline createImage(image_location: string): ImageData {\n\t\treturn createImage(image_location);\n\t}\n\n\t@inline imageReady(image_id: ImageData): bool {\n\t\treturn imageReady(image_id);\n\t}\n\n\t@inline get ALPHA_DEFAULT(): bool {\n\t\treturn ALPHA_DEFAULT;\n\t}\n\n\t@inline get FALSE(): GLboolean {\n\t\treturn FALSE;\n\t}\n\n\t@inline getAlpha(): GLboolean {\n\t\treturn getAlpha(this.gl_id);\n\t}\n\n\t@inline setAlpha(value: GLboolean): void {\n\t\tsetAlpha(this.gl_id, value);\n\t}\n\n\t@inline get DEPTH_DEFAULT(): bool {\n\t\treturn DEPTH_DEFAULT;\n\t}\n\n\t@inline getDepth(): GLboolean {\n\t\treturn getDepth(this.gl_id);\n\t}\n\n\t@inline setDepth(value: GLboolean): void {\n\t\tsetDepth(this.gl_id, value);\n\t}\n\n\t@inline get STENCIL_DEFAULT(): bool {\n\t\treturn STENCIL_DEFAULT;\n\t}\n\n\t@inline getStencil(): GLboolean {\n\t\treturn getStencil(this.gl_id);\n\t}\n\n\t@inline setStencil(value: GLboolean): void {\n\t\tsetStencil(this.gl_id, value);\n\t}\n\n\t@inline get ANTIALIAS_DEFAULT(): bool {\n\t\treturn ANTIALIAS_DEFAULT;\n\t}\n\n\t@inline getAntialias(): GLboolean {\n\t\treturn getAntialias(this.gl_id);\n\t}\n\n\t@inline setAntialias(value: GLboolean): void {\n\t\tsetAntialias(this.gl_id, value);\n\t}\n\n\t@inline get PREMULTIPLIED_ALPHA_DEFAULT(): bool {\n\t\treturn PREMULTIPLIED_ALPHA_DEFAULT;\n\t}\n\n\t@inline getPremultipliedAlpha(): GLboolean {\n\t\treturn getPremultipliedAlpha(this.gl_id);\n\t}\n\n\t@inline setPremultipliedAlpha(value: GLboolean): void {\n\t\tsetPremultipliedAlpha(this.gl_id, value);\n\t}\n\n\t@inline get PRESERVE_DRAWING_BUFFER_DEFAULT(): bool {\n\t\treturn PRESERVE_DRAWING_BUFFER_DEFAULT;\n\t}\n\n\t@inline getPreserveDrawingBuffer(): GLboolean {\n\t\treturn getPreserveDrawingBuffer(this.gl_id);\n\t}\n\n\t@inline setPreserveDrawingBuffer(value: GLboolean): void {\n\t\tsetPreserveDrawingBuffer(this.gl_id, value);\n\t}\n\n\t@inline getSize(): GLint {\n    // @ts-ignore\n\t\treturn getSize(this.gl_id);\n\t}\n\n\t@inline getType(): GLenum {\n    // @ts-ignore\n\t\treturn getType(this.gl_id);\n\t}\n\n\t@inline getName(): string {\n    // @ts-ignore\n\t\treturn getName(this.gl_id);\n\t}\n\n\t@inline getRangeMin(): GLint {\n    // @ts-ignore\n\t\treturn getRangeMin(this.gl_id);\n\t}\n\n\t@inline getRangeMax(): GLint {\n    // @ts-ignore\n\t\treturn getRangeMax(this.gl_id);\n\t}\n\t@inline getPrecision(): GLint {\n    // @ts-ignore\n\t\treturn getPrecision(this.gl_id)\n\t}\n\n\t@inline get DEPTH_BUFFER_BIT(): GLenum {\n\t\treturn DEPTH_BUFFER_BIT;\n\t}\n\n\t@inline get STENCIL_BUFFER_BIT(): GLenum {\n\t\treturn STENCIL_BUFFER_BIT;\n\t}\n\n\t@inline get COLOR_BUFFER_BIT(): GLenum {\n\t\treturn COLOR_BUFFER_BIT;\n\t}\n\n\t@inline get POINTS(): GLenum {\n\t\treturn POINTS;\n\t}\n\n\t@inline get LINES(): GLenum {\n\t\treturn LINES;\n\t}\n\n\t@inline get LINE_LOOP(): GLenum {\n\t\treturn LINE_LOOP;\n\t}\n\n\t@inline get LINE_STRIP(): GLenum {\n\t\treturn LINE_STRIP;\n\t}\n\n\t@inline get TRIANGLES(): GLenum {\n\t\treturn TRIANGLES;\n\t}\n\n\t@inline get TRIANGLE_STRIP(): GLenum {\n\t\treturn TRIANGLE_STRIP;\n\t}\n\n\t@inline get TRIANGLE_FAN(): GLenum {\n\t\treturn TRIANGLE_FAN;\n\t}\n\n\t@inline get ZERO(): GLenum {\n\t\treturn ZERO;\n\t}\n\n\t@inline get ONE(): GLenum {\n\t\treturn ONE;\n\t}\n\n\t@inline get SRC_COLOR(): GLenum {\n\t\treturn SRC_COLOR;\n\t}\n\n\t@inline get ONE_MINUS_SRC_COLOR(): GLenum {\n\t\treturn ONE_MINUS_SRC_COLOR;\n\t}\n\n\t@inline get SRC_ALPHA(): GLenum {\n\t\treturn SRC_ALPHA;\n\t}\n\n\t@inline get ONE_MINUS_SRC_ALPHA(): GLenum {\n\t\treturn ONE_MINUS_SRC_ALPHA;\n\t}\n\n\t@inline get DST_ALPHA(): GLenum {\n\t\treturn DST_ALPHA;\n\t}\n\n\t@inline get ONE_MINUS_DST_ALPHA(): GLenum {\n\t\treturn ONE_MINUS_DST_ALPHA;\n\t}\n\n\t@inline get DST_COLOR(): GLenum {\n\t\treturn DST_COLOR;\n\t}\n\n\t@inline get ONE_MINUS_DST_COLOR(): GLenum {\n\t\treturn ONE_MINUS_DST_COLOR;\n\t}\n\n\t@inline get SRC_ALPHA_SATURATE(): GLenum {\n\t\treturn SRC_ALPHA_SATURATE;\n\t}\n\n\t@inline get FUNC_ADD(): GLenum {\n\t\treturn FUNC_ADD;\n\t}\n\n\t@inline get BLEND_EQUATION(): GLenum {\n\t\treturn BLEND_EQUATION;\n\t}\n\n\t@inline get BLEND_EQUATION_RGB(): GLenum {\n\t\treturn BLEND_EQUATION_RGB;\n\t}\n\n\t@inline get BLEND_EQUATION_ALPHA(): GLenum {\n\t\treturn BLEND_EQUATION_ALPHA;\n\t}\n\n\t@inline get FUNC_SUBTRACT(): GLenum {\n\t\treturn FUNC_SUBTRACT;\n\t}\n\n\t@inline get FUNC_REVERSE_SUBTRACT(): GLenum {\n\t\treturn FUNC_REVERSE_SUBTRACT;\n\t}\n\n\t@inline get BLEND_DST_RGB(): GLenum {\n\t\treturn BLEND_DST_RGB;\n\t}\n\n\t@inline get BLEND_SRC_RGB(): GLenum {\n\t\treturn BLEND_SRC_RGB;\n\t}\n\n\t@inline get BLEND_DST_ALPHA(): GLenum {\n\t\treturn BLEND_DST_ALPHA;\n\t}\n\n\t@inline get BLEND_SRC_ALPHA(): GLenum {\n\t\treturn BLEND_SRC_ALPHA;\n\t}\n\n\t@inline get CONSTANT_COLOR(): GLenum {\n\t\treturn CONSTANT_COLOR;\n\t}\n\n\t@inline get ONE_MINUS_CONSTANT_COLOR(): GLenum {\n\t\treturn ONE_MINUS_CONSTANT_COLOR;\n\t}\n\n\t@inline get CONSTANT_ALPHA(): GLenum {\n\t\treturn CONSTANT_ALPHA;\n\t}\n\n\t@inline get ONE_MINUS_CONSTANT_ALPHA(): GLenum {\n\t\treturn ONE_MINUS_CONSTANT_ALPHA;\n\t}\n\n\t@inline get BLEND_COLOR(): GLenum {\n\t\treturn BLEND_COLOR;\n\t}\n\n\t@inline get ARRAY_BUFFER(): GLenum {\n\t\treturn ARRAY_BUFFER;\n\t}\n\n\t@inline get ELEMENT_ARRAY_BUFFER(): GLenum {\n\t\treturn ELEMENT_ARRAY_BUFFER;\n\t}\n\n\t@inline get ARRAY_BUFFER_BINDING(): GLenum {\n\t\treturn ARRAY_BUFFER_BINDING;\n\t}\n\n\t@inline get ELEMENT_ARRAY_BUFFER_BINDING(): GLenum {\n\t\treturn ELEMENT_ARRAY_BUFFER_BINDING;\n\t}\n\n\t@inline get STREAM_DRAW(): GLenum {\n\t\treturn STREAM_DRAW;\n\t}\n\n\t@inline get STATIC_DRAW(): GLenum {\n\t\treturn STATIC_DRAW;\n\t}\n\n\t@inline get DYNAMIC_DRAW(): GLenum {\n\t\treturn DYNAMIC_DRAW;\n\t}\n\n\t@inline get BUFFER_SIZE(): GLenum {\n\t\treturn BUFFER_SIZE;\n\t}\n\n\t@inline get BUFFER_USAGE(): GLenum {\n\t\treturn BUFFER_USAGE;\n\t}\n\n\t@inline get CURRENT_VERTEX_ATTRIB(): GLenum {\n\t\treturn CURRENT_VERTEX_ATTRIB;\n\t}\n\n\t@inline get FRONT(): GLenum {\n\t\treturn FRONT;\n\t}\n\n\t@inline get BACK(): GLenum {\n\t\treturn BACK;\n\t}\n\n\t@inline get FRONT_AND_BACK(): GLenum {\n\t\treturn FRONT_AND_BACK;\n\t}\n\n\t@inline get CULL_FACE(): GLenum {\n\t\treturn CULL_FACE;\n\t}\n\n\t@inline get BLEND(): GLenum {\n\t\treturn BLEND;\n\t}\n\n\t@inline get DITHER(): GLenum {\n\t\treturn DITHER;\n\t}\n\n\t@inline get STENCIL_TEST(): GLenum {\n\t\treturn STENCIL_TEST;\n\t}\n\n\t@inline get DEPTH_TEST(): GLenum {\n\t\treturn DEPTH_TEST;\n\t}\n\n\t@inline get SCISSOR_TEST(): GLenum {\n\t\treturn SCISSOR_TEST;\n\t}\n\n\t@inline get POLYGON_OFFSET_FILL(): GLenum {\n\t\treturn POLYGON_OFFSET_FILL;\n\t}\n\n\t@inline get SAMPLE_ALPHA_TO_COVERAGE(): GLenum {\n\t\treturn SAMPLE_ALPHA_TO_COVERAGE;\n\t}\n\n\t@inline get SAMPLE_COVERAGE(): GLenum {\n\t\treturn SAMPLE_COVERAGE;\n\t}\n\n\t@inline get NO_ERROR(): GLenum {\n\t\treturn NO_ERROR;\n\t}\n\n\t@inline get INVALID_ENUM(): GLenum {\n\t\treturn INVALID_ENUM;\n\t}\n\n\t@inline get INVALID_VALUE(): GLenum {\n\t\treturn INVALID_VALUE;\n\t}\n\n\t@inline get INVALID_OPERATION(): GLenum {\n\t\treturn INVALID_OPERATION;\n\t}\n\n\t@inline get OUT_OF_MEMORY(): GLenum {\n\t\treturn OUT_OF_MEMORY;\n\t}\n\n\t@inline get CW(): GLenum {\n\t\treturn CW;\n\t}\n\n\t@inline get CCW(): GLenum {\n\t\treturn CCW;\n\t}\n\n\t@inline get LINE_WIDTH(): GLenum {\n\t\treturn LINE_WIDTH;\n\t}\n\n\t@inline get ALIASED_POINT_SIZE_RANGE(): GLenum {\n\t\treturn ALIASED_POINT_SIZE_RANGE;\n\t}\n\n\t@inline get ALIASED_LINE_WIDTH_RANGE(): GLenum {\n\t\treturn ALIASED_LINE_WIDTH_RANGE;\n\t}\n\n\t@inline get CULL_FACE_MODE(): GLenum {\n\t\treturn CULL_FACE_MODE;\n\t}\n\n\t@inline get FRONT_FACE(): GLenum {\n\t\treturn FRONT_FACE;\n\t}\n\n\t@inline get DEPTH_RANGE(): GLenum {\n\t\treturn DEPTH_RANGE;\n\t}\n\n\t@inline get DEPTH_WRITEMASK(): GLenum {\n\t\treturn DEPTH_WRITEMASK;\n\t}\n\n\t@inline get DEPTH_CLEAR_VALUE(): GLenum {\n\t\treturn DEPTH_CLEAR_VALUE;\n\t}\n\n\t@inline get DEPTH_FUNC(): GLenum {\n\t\treturn DEPTH_FUNC;\n\t}\n\n\t@inline get STENCIL_CLEAR_VALUE(): GLenum {\n\t\treturn STENCIL_CLEAR_VALUE;\n\t}\n\n\t@inline get STENCIL_FUNC(): GLenum {\n\t\treturn STENCIL_FUNC;\n\t}\n\n\t@inline get STENCIL_FAIL(): GLenum {\n\t\treturn STENCIL_FAIL;\n\t}\n\n\t@inline get STENCIL_PASS_DEPTH_FAIL(): GLenum {\n\t\treturn STENCIL_PASS_DEPTH_FAIL;\n\t}\n\n\t@inline get STENCIL_PASS_DEPTH_PASS(): GLenum {\n\t\treturn STENCIL_PASS_DEPTH_PASS;\n\t}\n\n\t@inline get STENCIL_REF(): GLenum {\n\t\treturn STENCIL_REF;\n\t}\n\n\t@inline get STENCIL_VALUE_MASK(): GLenum {\n\t\treturn STENCIL_VALUE_MASK;\n\t}\n\n\t@inline get STENCIL_WRITEMASK(): GLenum {\n\t\treturn STENCIL_WRITEMASK;\n\t}\n\n\t@inline get STENCIL_BACK_FUNC(): GLenum {\n\t\treturn STENCIL_BACK_FUNC;\n\t}\n\n\t@inline get STENCIL_BACK_FAIL(): GLenum {\n\t\treturn STENCIL_BACK_FAIL;\n\t}\n\n\t@inline get STENCIL_BACK_PASS_DEPTH_FAIL(): GLenum {\n\t\treturn STENCIL_BACK_PASS_DEPTH_FAIL;\n\t}\n\n\t@inline get STENCIL_BACK_PASS_DEPTH_PASS(): GLenum {\n\t\treturn STENCIL_BACK_PASS_DEPTH_PASS;\n\t}\n\n\t@inline get STENCIL_BACK_REF(): GLenum {\n\t\treturn STENCIL_BACK_REF;\n\t}\n\n\t@inline get STENCIL_BACK_VALUE_MASK(): GLenum {\n\t\treturn STENCIL_BACK_VALUE_MASK;\n\t}\n\n\t@inline get STENCIL_BACK_WRITEMASK(): GLenum {\n\t\treturn STENCIL_BACK_WRITEMASK;\n\t}\n\n\t@inline get VIEWPORT(): GLenum {\n\t\treturn VIEWPORT;\n\t}\n\n\t@inline get SCISSOR_BOX(): GLenum {\n\t\treturn SCISSOR_BOX;\n\t}\n\n\t@inline get COLOR_CLEAR_VALUE(): GLenum {\n\t\treturn COLOR_CLEAR_VALUE;\n\t}\n\n\t@inline get COLOR_WRITEMASK(): GLenum {\n\t\treturn COLOR_WRITEMASK;\n\t}\n\n\t@inline get UNPACK_ALIGNMENT(): GLenum {\n\t\treturn UNPACK_ALIGNMENT;\n\t}\n\n\t@inline get PACK_ALIGNMENT(): GLenum {\n\t\treturn PACK_ALIGNMENT;\n\t}\n\n\t@inline get MAX_TEXTURE_SIZE(): GLenum {\n\t\treturn MAX_TEXTURE_SIZE;\n\t}\n\n\t@inline get MAX_VIEWPORT_DIMS(): GLenum {\n\t\treturn MAX_VIEWPORT_DIMS;\n\t}\n\n\t@inline get SUBPIXEL_BITS(): GLenum {\n\t\treturn SUBPIXEL_BITS;\n\t}\n\n\t@inline get RED_BITS(): GLenum {\n\t\treturn RED_BITS;\n\t}\n\n\t@inline get GREEN_BITS(): GLenum {\n\t\treturn GREEN_BITS;\n\t}\n\n\t@inline get BLUE_BITS(): GLenum {\n\t\treturn BLUE_BITS;\n\t}\n\n\t@inline get ALPHA_BITS(): GLenum {\n\t\treturn ALPHA_BITS;\n\t}\n\n\t@inline get DEPTH_BITS(): GLenum {\n\t\treturn DEPTH_BITS;\n\t}\n\n\t@inline get STENCIL_BITS(): GLenum {\n\t\treturn STENCIL_BITS;\n\t}\n\n\t@inline get POLYGON_OFFSET_UNITS(): GLenum {\n\t\treturn POLYGON_OFFSET_UNITS;\n\t}\n\n\t@inline get POLYGON_OFFSET_FACTOR(): GLenum {\n\t\treturn POLYGON_OFFSET_FACTOR;\n\t}\n\n\t@inline get TEXTURE_BINDING_2D(): GLenum {\n\t\treturn TEXTURE_BINDING_2D;\n\t}\n\n\t@inline get SAMPLE_BUFFERS(): GLenum {\n\t\treturn SAMPLE_BUFFERS;\n\t}\n\n\t@inline get SAMPLES(): GLenum {\n\t\treturn SAMPLES;\n\t}\n\n\t@inline get SAMPLE_COVERAGE_VALUE(): GLenum {\n\t\treturn SAMPLE_COVERAGE_VALUE;\n\t}\n\n\t@inline get SAMPLE_COVERAGE_INVERT(): GLenum {\n\t\treturn SAMPLE_COVERAGE_INVERT;\n\t}\n\n\t@inline get COMPRESSED_TEXTURE_FORMATS(): GLenum {\n\t\treturn COMPRESSED_TEXTURE_FORMATS;\n\t}\n\n\t@inline get DONT_CARE(): GLenum {\n\t\treturn DONT_CARE;\n\t}\n\n\t@inline get FASTEST(): GLenum {\n\t\treturn FASTEST;\n\t}\n\n\t@inline get NICEST(): GLenum {\n\t\treturn NICEST;\n\t}\n\n\t@inline get GENERATE_MIPMAP_HINT(): GLenum {\n\t\treturn GENERATE_MIPMAP_HINT;\n\t}\n\n\t@inline get BYTE(): GLenum {\n\t\treturn BYTE;\n\t}\n\n\t@inline get UNSIGNED_BYTE(): GLenum {\n\t\treturn UNSIGNED_BYTE;\n\t}\n\n\t@inline get SHORT(): GLenum {\n\t\treturn SHORT;\n\t}\n\n\t@inline get UNSIGNED_SHORT(): GLenum {\n\t\treturn UNSIGNED_SHORT;\n\t}\n\n\t@inline get INT(): GLenum {\n\t\treturn INT;\n\t}\n\n\t@inline get UNSIGNED_INT(): GLenum {\n\t\treturn UNSIGNED_INT;\n\t}\n\n\t@inline get FLOAT(): GLenum {\n\t\treturn FLOAT;\n\t}\n\n\t@inline get DEPTH_COMPONENT(): GLenum {\n\t\treturn DEPTH_COMPONENT;\n\t}\n\n\t@inline get ALPHA(): GLenum {\n\t\treturn ALPHA;\n\t}\n\n\t@inline get RGB(): GLenum {\n\t\treturn RGB;\n\t}\n\n\t@inline get RGBA(): GLenum {\n\t\treturn RGBA;\n\t}\n\n\t@inline get LUMINANCE(): GLenum {\n\t\treturn LUMINANCE;\n\t}\n\n\t@inline get LUMINANCE_ALPHA(): GLenum {\n\t\treturn LUMINANCE_ALPHA;\n\t}\n\n\t@inline get UNSIGNED_SHORT_4_4_4_4(): GLenum {\n\t\treturn UNSIGNED_SHORT_4_4_4_4;\n\t}\n\n\t@inline get UNSIGNED_SHORT_5_5_5_1(): GLenum {\n\t\treturn UNSIGNED_SHORT_5_5_5_1;\n\t}\n\n\t@inline get UNSIGNED_SHORT_5_6_5(): GLenum {\n\t\treturn UNSIGNED_SHORT_5_6_5;\n\t}\n\n\t@inline get FRAGMENT_SHADER(): GLenum {\n\t\treturn FRAGMENT_SHADER;\n\t}\n\n\t@inline get VERTEX_SHADER(): GLenum {\n\t\treturn VERTEX_SHADER;\n\t}\n\n\t@inline get MAX_VERTEX_ATTRIBS(): GLenum {\n\t\treturn MAX_VERTEX_ATTRIBS;\n\t}\n\n\t@inline get MAX_VERTEX_UNIFORM_VECTORS(): GLenum {\n\t\treturn MAX_VERTEX_UNIFORM_VECTORS;\n\t}\n\n\t@inline get MAX_VARYING_VECTORS(): GLenum {\n\t\treturn MAX_VARYING_VECTORS;\n\t}\n\n\t@inline get MAX_COMBINED_TEXTURE_IMAGE_UNITS(): GLenum {\n\t\treturn MAX_COMBINED_TEXTURE_IMAGE_UNITS;\n\t}\n\n\t@inline get MAX_VERTEX_TEXTURE_IMAGE_UNITS(): GLenum {\n\t\treturn MAX_VERTEX_TEXTURE_IMAGE_UNITS;\n\t}\n\n\t@inline get MAX_TEXTURE_IMAGE_UNITS(): GLenum {\n\t\treturn MAX_TEXTURE_IMAGE_UNITS;\n\t}\n\n\t@inline get MAX_FRAGMENT_UNIFORM_VECTORS(): GLenum {\n\t\treturn MAX_FRAGMENT_UNIFORM_VECTORS;\n\t}\n\n\t@inline get SHADER_TYPE(): GLenum {\n\t\treturn SHADER_TYPE;\n\t}\n\n\t@inline get DELETE_STATUS(): GLenum {\n\t\treturn DELETE_STATUS;\n\t}\n\n\t@inline get LINK_STATUS(): GLenum {\n\t\treturn LINK_STATUS;\n\t}\n\n\t@inline get VALIDATE_STATUS(): GLenum {\n\t\treturn VALIDATE_STATUS;\n\t}\n\n\t@inline get ATTACHED_SHADERS(): GLenum {\n\t\treturn ATTACHED_SHADERS;\n\t}\n\n\t@inline get ACTIVE_UNIFORMS(): GLenum {\n\t\treturn ACTIVE_UNIFORMS;\n\t}\n\n\t@inline get ACTIVE_ATTRIBUTES(): GLenum {\n\t\treturn ACTIVE_ATTRIBUTES;\n\t}\n\n\t@inline get SHADING_LANGUAGE_VERSION(): GLenum {\n\t\treturn SHADING_LANGUAGE_VERSION;\n\t}\n\n\t@inline get CURRENT_PROGRAM(): GLenum {\n\t\treturn CURRENT_PROGRAM;\n\t}\n\n\t@inline get NEVER(): GLenum {\n\t\treturn NEVER;\n\t}\n\n\t@inline get LESS(): GLenum {\n\t\treturn LESS;\n\t}\n\n\t@inline get EQUAL(): GLenum {\n\t\treturn EQUAL;\n\t}\n\n\t@inline get LEQUAL(): GLenum {\n\t\treturn LEQUAL;\n\t}\n\n\t@inline get GREATER(): GLenum {\n\t\treturn GREATER;\n\t}\n\n\t@inline get NOTEQUAL(): GLenum {\n\t\treturn NOTEQUAL;\n\t}\n\n\t@inline get GEQUAL(): GLenum {\n\t\treturn GEQUAL;\n\t}\n\n\t@inline get ALWAYS(): GLenum {\n\t\treturn ALWAYS;\n\t}\n\n\t@inline get KEEP(): GLenum {\n\t\treturn KEEP;\n\t}\n\n\t@inline get REPLACE(): GLenum {\n\t\treturn REPLACE;\n\t}\n\n\t@inline get INCR(): GLenum {\n\t\treturn INCR;\n\t}\n\n\t@inline get DECR(): GLenum {\n\t\treturn DECR;\n\t}\n\n\t@inline get INVERT(): GLenum {\n\t\treturn INVERT;\n\t}\n\n\t@inline get INCR_WRAP(): GLenum {\n\t\treturn INCR_WRAP;\n\t}\n\n\t@inline get DECR_WRAP(): GLenum {\n\t\treturn DECR_WRAP;\n\t}\n\n\n\t@inline get VENDOR(): GLenum {\n\t\treturn VENDOR;\n\t}\n\n\t@inline get RENDERER(): GLenum {\n\t\treturn RENDERER;\n\t}\n\n\t@inline get VERSION(): GLenum {\n\t\treturn VERSION;\n\t}\n\n\t@inline get NEAREST(): GLenum {\n\t\treturn NEAREST;\n\t}\n\n\t@inline get LINEAR(): GLenum {\n\t\treturn LINEAR;\n\t}\n\n\t@inline get NEAREST_MIPMAP_NEAREST(): GLenum {\n\t\treturn NEAREST_MIPMAP_NEAREST;\n\t}\n\n\t@inline get LINEAR_MIPMAP_NEAREST(): GLenum {\n\t\treturn LINEAR_MIPMAP_NEAREST;\n\t}\n\n\t@inline get NEAREST_MIPMAP_LINEAR(): GLenum {\n\t\treturn NEAREST_MIPMAP_LINEAR;\n\t}\n\n\t@inline get LINEAR_MIPMAP_LINEAR(): GLenum {\n\t\treturn LINEAR_MIPMAP_LINEAR;\n\t}\n\n\t@inline get TEXTURE_MAG_FILTER(): GLenum {\n\t\treturn TEXTURE_MAG_FILTER;\n\t}\n\n\t@inline get TEXTURE_MIN_FILTER(): GLenum {\n\t\treturn TEXTURE_MIN_FILTER;\n\t}\n\n\t@inline get TEXTURE_WRAP_S(): GLenum {\n\t\treturn LINEAR;\n\t}\n\n\t@inline get TEXTURE_WRAP_T(): GLenum {\n\t\treturn TEXTURE_WRAP_T;\n\t}\n\n\t@inline get TEXTURE_2D(): GLenum {\n\t\treturn TEXTURE_2D;\n\t}\n\n\t@inline get TEXTURE(): GLenum {\n\t\treturn TEXTURE;\n\t}\n\n\t@inline get TEXTURE_CUBE_MAP(): GLenum {\n\t\treturn TEXTURE_CUBE_MAP;\n\t}\n\n\t@inline get TEXTURE_BINDING_CUBE_MAP(): GLenum {\n\t\treturn TEXTURE_BINDING_CUBE_MAP;\n\t}\n\n\t@inline get TEXTURE_CUBE_MAP_POSITIVE_X(): GLenum {\n\t\treturn TEXTURE_CUBE_MAP_POSITIVE_X;\n\t}\n\n\t@inline get TEXTURE_CUBE_MAP_NEGATIVE_X(): GLenum {\n\t\treturn TEXTURE_CUBE_MAP_NEGATIVE_X;\n\t}\n\n\t@inline get TEXTURE_CUBE_MAP_POSITIVE_Y(): GLenum {\n\t\treturn TEXTURE_CUBE_MAP_POSITIVE_Y;\n\t}\n\n\t@inline get TEXTURE_CUBE_MAP_NEGATIVE_Y(): GLenum {\n\t\treturn TEXTURE_CUBE_MAP_NEGATIVE_Y;\n\t}\n\n\t@inline get TEXTURE_CUBE_MAP_POSITIVE_Z(): GLenum {\n\t\treturn TEXTURE_CUBE_MAP_POSITIVE_Z;\n\t}\n\n\t@inline get TEXTURE_CUBE_MAP_NEGATIVE_Z(): GLenum {\n\t\treturn TEXTURE_CUBE_MAP_NEGATIVE_Z;\n\t}\n\n\t@inline get MAX_CUBE_MAP_TEXTURE_SIZE(): GLenum {\n\t\treturn MAX_CUBE_MAP_TEXTURE_SIZE;\n\t}\n\n\t@inline get TEXTURE0(): GLenum {\n\t\treturn TEXTURE0;\n\t}\n\t@inline get TEXTURE1(): GLenum {\n\t\treturn TEXTURE1;\n\t}\n\t@inline get TEXTURE2(): GLenum {\n\t\treturn TEXTURE2;\n\t}\n\t@inline get TEXTURE3(): GLenum {\n\t\treturn TEXTURE3;\n\t}\n\t@inline get TEXTURE4(): GLenum {\n\t\treturn TEXTURE4;\n\t}\n\t@inline get TEXTURE5(): GLenum {\n\t\treturn TEXTURE5;\n\t}\n\t@inline get TEXTURE6(): GLenum {\n\t\treturn TEXTURE6;\n\t}\n\t@inline get TEXTURE7(): GLenum {\n\t\treturn TEXTURE7;\n\t}\n\t@inline get TEXTURE8(): GLenum {\n\t\treturn TEXTURE8;\n\t}\n\t@inline get TEXTURE9(): GLenum {\n\t\treturn TEXTURE9;\n\t}\n\t//---\n\n\t@inline get TEXTURE10(): GLenum {\n\t\treturn TEXTURE10;\n\t}\n\t@inline get TEXTURE11(): GLenum {\n\t\treturn TEXTURE11;\n\t}\n\t@inline get TEXTURE12(): GLenum {\n\t\treturn TEXTURE12;\n\t}\n\t@inline get TEXTURE13(): GLenum {\n\t\treturn TEXTURE13;\n\t}\n\t@inline get TEXTURE14(): GLenum {\n\t\treturn TEXTURE14;\n\t}\n\t@inline get TEXTURE15(): GLenum {\n\t\treturn TEXTURE15;\n\t}\n\t@inline get TEXTURE16(): GLenum {\n\t\treturn TEXTURE16;\n\t}\n\t@inline get TEXTURE17(): GLenum {\n\t\treturn TEXTURE17;\n\t}\n\t@inline get TEXTURE18(): GLenum {\n\t\treturn TEXTURE18;\n\t}\n\t@inline get TEXTURE19(): GLenum {\n\t\treturn TEXTURE19;\n\t}\n\t// --\n\t@inline get TEXTURE20(): GLenum {\n\t\treturn TEXTURE20;\n\t}\n\t@inline get TEXTURE21(): GLenum {\n\t\treturn TEXTURE21;\n\t}\n\t@inline get TEXTURE22(): GLenum {\n\t\treturn TEXTURE22;\n\t}\n\t@inline get TEXTURE23(): GLenum {\n\t\treturn TEXTURE23;\n\t}\n\t@inline get TEXTURE24(): GLenum {\n\t\treturn TEXTURE24;\n\t}\n\t@inline get TEXTURE25(): GLenum {\n\t\treturn TEXTURE25;\n\t}\n\t@inline get TEXTURE26(): GLenum {\n\t\treturn TEXTURE26;\n\t}\n\t@inline get TEXTURE27(): GLenum {\n\t\treturn TEXTURE27;\n\t}\n\t@inline get TEXTURE28(): GLenum {\n\t\treturn TEXTURE28;\n\t}\n\t@inline get TEXTURE29(): GLenum {\n\t\treturn TEXTURE29;\n\t}\n\n\t@inline get TEXTURE30(): GLenum {\n\t\treturn TEXTURE30;\n\t}\n\t@inline get TEXTURE31(): GLenum {\n\t\treturn TEXTURE31;\n\t}\n\n\t@inline get ACTIVE_TEXTURE(): GLenum {\n\t\treturn ACTIVE_TEXTURE;\n\t}\n\n\t@inline get REPEAT(): GLenum {\n\t\treturn REPEAT;\n\t}\n\n\t@inline get CLAMP_TO_EDGE(): GLenum {\n\t\treturn CLAMP_TO_EDGE;\n\t}\n\n\t@inline get MIRRORED_REPEAT(): GLenum {\n\t\treturn MIRRORED_REPEAT;\n\t}\n\n\t@inline get FLOAT_VEC2(): GLenum {\n\t\treturn FLOAT_VEC2;\n\t}\n\n\t@inline get FLOAT_VEC3(): GLenum {\n\t\treturn FLOAT_VEC3;\n\t}\n\n\t@inline get FLOAT_VEC4(): GLenum {\n\t\treturn FLOAT_VEC4;\n\t}\n\n\t@inline get INT_VEC2(): GLenum {\n\t\treturn INT_VEC2;\n\t}\n\n\t@inline get INT_VEC3(): GLenum {\n\t\treturn INT_VEC3;\n\t}\n\n\t@inline get INT_VEC4(): GLenum {\n\t\treturn INT_VEC4;\n\t}\n\n\t@inline get BOOL(): GLenum {\n\t\treturn BOOL;\n\t}\n\n\t@inline get BOOL_VEC2(): GLenum {\n\t\treturn BOOL_VEC2;\n\t}\n\n\t@inline get BOOL_VEC3(): GLenum {\n\t\treturn REPEAT;\n\t}\n\n\t@inline get BOOL_VEC4(): GLenum {\n\t\treturn BOOL_VEC4;\n\t}\n\n\t@inline get FLOAT_MAT2(): GLenum {\n\t\treturn FLOAT_MAT2;\n\t}\n\n\t@inline get FLOAT_MAT3(): GLenum {\n\t\treturn FLOAT_MAT3;\n\t}\n\n\t@inline get FLOAT_MAT4(): GLenum {\n\t\treturn FLOAT_MAT4;\n\t}\n\n\t@inline get SAMPLER_2D(): GLenum {\n\t\treturn SAMPLER_2D;\n\t}\n\n\t@inline get SAMPLER_CUBE(): GLenum {\n\t\treturn SAMPLER_CUBE;\n\t}\n\n\t@inline get VERTEX_ATTRIB_ARRAY_ENABLED(): GLenum {\n\t\treturn VERTEX_ATTRIB_ARRAY_ENABLED;\n\t}\n\n\t@inline get VERTEX_ATTRIB_ARRAY_SIZE(): GLenum {\n\t\treturn VERTEX_ATTRIB_ARRAY_SIZE;\n\t}\n\n\t@inline get VERTEX_ATTRIB_ARRAY_STRIDE(): GLenum {\n\t\treturn VERTEX_ATTRIB_ARRAY_STRIDE;\n\t}\n\n\t@inline get VERTEX_ATTRIB_ARRAY_TYPE(): GLenum {\n\t\treturn VERTEX_ATTRIB_ARRAY_TYPE;\n\t}\n\n\t@inline get VERTEX_ATTRIB_ARRAY_NORMALIZED(): GLenum {\n\t\treturn VERTEX_ATTRIB_ARRAY_NORMALIZED;\n\t}\n\n\t@inline get VERTEX_ATTRIB_ARRAY_POINTER(): GLenum {\n\t\treturn VERTEX_ATTRIB_ARRAY_POINTER;\n\t}\n\n\t@inline get VERTEX_ATTRIB_ARRAY_BUFFER_BINDING(): GLenum {\n\t\treturn VERTEX_ATTRIB_ARRAY_BUFFER_BINDING;\n\t}\n\n\t@inline get COMPILE_STATUS(): GLenum {\n\t\treturn COMPILE_STATUS;\n\t}\n\n\t@inline get LOW_FLOAT(): GLenum {\n\t\treturn LOW_FLOAT;\n\t}\n\n\t@inline get MEDIUM_FLOAT(): GLenum {\n\t\treturn MEDIUM_FLOAT;\n\t}\n\n\t@inline get HIGH_FLOAT(): GLenum {\n\t\treturn HIGH_FLOAT;\n\t}\n\n\t@inline get LOW_INT(): GLenum {\n\t\treturn LOW_INT;\n\t}\n\n\t@inline get MEDIUM_INT(): GLenum {\n\t\treturn MEDIUM_INT;\n\t}\n\n\t@inline get HIGH_INT(): GLenum {\n\t\treturn HIGH_INT;\n\t}\n\n\t@inline get FRAMEBUFFER(): GLenum {\n\t\treturn FRAMEBUFFER;\n\t}\n\n\t@inline get RENDERBUFFER(): GLenum {\n\t\treturn RENDERBUFFER;\n\t}\n\n\t@inline get RGBA4(): GLenum {\n\t\treturn RGBA4;\n\t}\n\n\t@inline get RGB5_A1(): GLenum {\n\t\treturn RGB5_A1;\n\t}\n\n\t@inline get RGB565(): GLenum {\n\t\treturn RGB565;\n\t}\n\n\t@inline get DEPTH_COMPONENT16(): GLenum {\n\t\treturn DEPTH_COMPONENT16;\n\t}\n\n\t@inline get STENCIL_INDEX(): GLenum {\n\t\treturn STENCIL_INDEX;\n\t}\n\n\t@inline get STENCIL_INDEX8(): GLenum {\n\t\treturn STENCIL_INDEX8;\n\t}\n\n\t@inline get DEPTH_STENCIL(): GLenum {\n\t\treturn DEPTH_STENCIL;\n\t}\n\n\t@inline get RENDERBUFFER_WIDTH(): GLenum {\n\t\treturn RENDERBUFFER_WIDTH;\n\t}\n\n\t@inline get RENDERBUFFER_HEIGHT(): GLenum {\n\t\treturn RENDERBUFFER_HEIGHT;\n\t}\n\n\t@inline get RENDERBUFFER_INTERNAL_FORMAT(): GLenum {\n\t\treturn RENDERBUFFER_INTERNAL_FORMAT;\n\t}\n\n\t@inline get RENDERBUFFER_RED_SIZE(): GLenum {\n\t\treturn RENDERBUFFER_RED_SIZE;\n\t}\n\n\t@inline get RENDERBUFFER_GREEN_SIZE(): GLenum {\n\t\treturn RENDERBUFFER_GREEN_SIZE;\n\t}\n\n\t@inline get RENDERBUFFER_BLUE_SIZE(): GLenum {\n\t\treturn RENDERBUFFER_BLUE_SIZE;\n\t}\n\n\t@inline get RENDERBUFFER_ALPHA_SIZE(): GLenum {\n\t\treturn RENDERBUFFER_ALPHA_SIZE;\n\t}\n\n\t@inline get RENDERBUFFER_DEPTH_SIZE(): GLenum {\n\t\treturn RENDERBUFFER_DEPTH_SIZE;\n\t}\n\n\t@inline get RENDERBUFFER_STENCIL_SIZE(): GLenum {\n\t\treturn RENDERBUFFER_STENCIL_SIZE;\n\t}\n\n\t@inline get FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE(): GLenum {\n\t\treturn FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE;\n\t}\n\n\t@inline get FRAMEBUFFER_ATTACHMENT_OBJECT_NAME(): GLenum {\n\t\treturn FRAMEBUFFER_ATTACHMENT_OBJECT_NAME;\n\t}\n\n\t@inline get FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL(): GLenum {\n\t\treturn FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL;\n\t}\n\n\t@inline get FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE(): GLenum {\n\t\treturn FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE;\n\t}\n\n\t@inline get COLOR_ATTACHMENT0(): GLenum {\n\t\treturn COLOR_ATTACHMENT0;\n\t}\n\n\t@inline get DEPTH_ATTACHMENT(): GLenum {\n\t\treturn DEPTH_ATTACHMENT;\n\t}\n\n\t@inline get STENCIL_ATTACHMENT(): GLenum {\n\t\treturn STENCIL_ATTACHMENT;\n\t}\n\n\t@inline get DEPTH_STENCIL_ATTACHMENT(): GLenum {\n\t\treturn DEPTH_STENCIL_ATTACHMENT;\n\t}\n\n\t@inline get NONE(): GLenum {\n\t\treturn NONE;\n\t}\n\n\t@inline get FRAMEBUFFER_COMPLETE(): GLenum {\n\t\treturn FRAMEBUFFER_COMPLETE;\n\t}\n\n\t@inline get FRAMEBUFFER_INCOMPLETE_ATTACHMENT(): GLenum {\n\t\treturn FRAMEBUFFER_INCOMPLETE_ATTACHMENT;\n\t}\n\n\t@inline get FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT(): GLenum {\n\t\treturn FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;\n\t}\n\n\t@inline get FRAMEBUFFER_INCOMPLETE_DIMENSIONS(): GLenum {\n\t\treturn FRAMEBUFFER_INCOMPLETE_DIMENSIONS;\n\t}\n\n\t@inline get FRAMEBUFFER_UNSUPPORTED(): GLenum {\n\t\treturn FRAMEBUFFER_UNSUPPORTED;\n\t}\n\n\t@inline get FRAMEBUFFER_BINDING(): GLenum {\n\t\treturn FRAMEBUFFER_BINDING;\n\t}\n\n\t@inline get RENDERBUFFER_BINDING(): GLenum {\n\t\treturn RENDERBUFFER_BINDING;\n\t}\n\n\t@inline get MAX_RENDERBUFFER_SIZE(): GLenum {\n\t\treturn MAX_RENDERBUFFER_SIZE;\n\t}\n\n\t@inline get INVALID_FRAMEBUFFER_OPERATION(): GLenum {\n\t\treturn INVALID_FRAMEBUFFER_OPERATION;\n\t}\n\n\t@inline get UNPACK_FLIP_Y_WEBGL(): GLenum {\n\t\treturn UNPACK_FLIP_Y_WEBGL;\n\t}\n\n\t@inline get UNPACK_PREMULTIPLY_ALPHA_WEBGL(): GLenum {\n\t\treturn UNPACK_PREMULTIPLY_ALPHA_WEBGL;\n\t}\n\n\t@inline get CONTEXT_LOST_WEBGL(): GLenum {\n\t\treturn CONTEXT_LOST_WEBGL;\n\t}\n\n\t@inline get UNPACK_COLORSPACE_CONVERSION_WEBGL(): GLenum {\n\t\treturn UNPACK_COLORSPACE_CONVERSION_WEBGL;\n\t}\n\n\t@inline get BROWSER_DEFAULT_WEBGL(): GLenum {\n\t\treturn BROWSER_DEFAULT_WEBGL;\n\t}\n\n\t/*\n\t@inline getDepth(): GLboolean {\n\t\tgetDepth(this.gl_id);\n\t}\n\t*/\n\n\t@inline getDrawingBufferWidth(): GLsizei {\n\t\treturn getDrawingBufferWidth(this.gl_id);\n\t}\n\t@inline getDrawingBufferHeight(): GLsizei {\n\t\treturn getDrawingBufferHeight(this.gl_id);\n\t}\n\n\t@inline getContextAttributes(): WebGLContextAttributes {\n\t\treturn getContextAttributes(this.gl_id);\n\t}\n\t@inline isContextLost(): bool {\n\t\treturn isContextLost(this.gl_id);\n\t}\n\n\t@inline getSupportedExtensions(): sequence<string> {\n\t\treturn getSupportedExtensions(this.gl_id);\n\t}\n\n\t@inline getExtension(name: string): object_ {\n\t\treturn getExtension(this.gl_id, name);\n\t}\n\n\t@inline activeTexture(texture: GLenum): void {\n\t\tactiveTexture(this.gl_id, texture);\n\t}\n\n\t@inline static createContextFromCanvas(canvas_id: string, context_type: string): WebGLRenderingContext {\n    return new WebGLRenderingContext(canvas_id, context_type)\n\t}\n\n\t@inline attachShader(program: WebGLProgram, shader: WebGLShader): void {\n\t\tattachShader(this.gl_id, program, shader);\n\t}\n\n\t// @inline bindAttribLocation(gl: WebGLRenderingContext, program: WebGLProgram, index: GLuint, name: string): void;\n\t@inline bindBuffer(target: GLenum, buffer: WebGLBuffer): void {\n\t\tbindBuffer(this.gl_id, target, buffer);\n\t}\n\t@inline bindFramebuffer(target: GLenum, framebuffer: WebGLFramebuffer): void {\n\t\tbindFramebuffer(this.gl_id, target, framebuffer);\n\t}\n\t@inline bindRenderbuffer(target: GLenum, renderbuffer: WebGLRenderbuffer): void {\n\t\tbindRenderbuffer(this.gl_id, target, renderbuffer);\n\t}\n\t@inline bindTexture(target: GLenum, texture: WebGLTexture): void {\n\t\tbindTexture(this.gl_id, target, texture);\n\t}\n\t@inline blendColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf): void {\n\t\tblendColor(this.gl_id, red, green, blue, alpha);\n\t}\n\t@inline blendEquation(mode: GLenum): void {\n\t\tblendEquation(this.gl_id, mode);\n\t}\n\t@inline blendEquationSeparate(modeRGB: GLenum, modeAlpha: GLenum): void {\n\t\tblendEquationSeparate(this.gl_id, modeRGB, modeAlpha);\n\t}\n\t@inline blendFunc(sfactor: GLenum, dfactor: GLenum): void {\n\t\tblendFunc(this.gl_id, sfactor, dfactor);\n\t}\n\t@inline blendFuncSeparate(srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum): void {\n\t\tblendFuncSeparate(this.gl_id, srcRGB, dstRGB, srcAlpha, dstAlpha);\n\t}\n\t@inline bufferData<T>(target: GLenum, data: StaticArray<T>, usage: GLenum): void {\n\t\tbufferData<T>(this.gl_id, target, data, usage);\n\t}\n\t@inline bufferSubData<T>(target: GLenum, offset: GLintptr, data: Array<T>): void {\n\t\tbufferSubData<T>(this.gl_id, target, offset, data)\n\t}\n\n\t@inline checkFramebufferStatus(target: GLenum): GLenum {\n\t\treturn checkFramebufferStatus(this.gl_id, target);\n\t}\n\t@inline clear(mask: GLbitfield): void {\n\t\tclear(this.gl_id, mask)\n\t}\n\n\t@inline clearColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf): void {\n\t\tclearColor(this.gl_id, red, green, blue, alpha);\n\t}\n\t@inline clearDepth(depth: GLclampf): void {\n\t\tclearDepth(this.gl_id, depth);\n\t}\n\t@inline clearStencil(s: GLint): void {\n\t\tclearStencil(this.gl_id, s);\n\t}\n\t@inline colorMask(red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean): void {\n\t\tcolorMask(this.gl_id, red, green, blue, alpha);\n\t}\n\t@inline compileShader(shader: WebGLShader): void {\n\t\tcompileShader(this.gl_id, shader);\n\t}\n\n\t@inline compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, data: ArrayBufferView): void {\n\t\tcompressedTexImage2D(this.gl_id, target, level, internalformat, width, height, border, data);\n\t}\n\t@inline compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, data: ArrayBufferView): void {\n\t\tcompressedTexSubImage2D(this.gl_id, target, level, xoffset, yoffset, width, height, format, data);\n\t}\n\n\t@inline copyTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint): void {\n\t\tcopyTexImage2D(this.gl_id, target, level, internalformat, x, y, width, height, border);\n\t}\n\t@inline copyTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {\n\t\tcopyTexSubImage2D(this.gl_id, target, level, xoffset, yoffset, x, y, width, height);\n\t}\n\n\t@inline createBuffer(): WebGLBuffer {\n\t\treturn createBuffer(this.gl_id);\n\t}\n\n\t@inline createFramebuffer(): WebGLFramebuffer {\n\t\treturn createFramebuffer(this.gl_id);\n\t}\n\n\t@inline createProgram(): WebGLProgram {\n\t\treturn createProgram(this.gl_id);\n\t}\n\t@inline createRenderbuffer(): WebGLRenderbuffer {\n\t\treturn createRenderbuffer(this.gl_id);\n\t}\n\t@inline createShader(typ: GLenum): WebGLShader {\n\t\treturn createShader(this.gl_id, typ);\n\t}\n\n\t@inline createTexture(): WebGLTexture {\n\t\treturn createTexture(this.gl_id)\n\t}\n\n\t@inline cullFace(mode: GLenum): void {\n\t\tcullFace(this.gl_id, mode);\n\t}\n\n\t@inline deleteBuffer(buffer: WebGLBuffer): void {\n\t\tdeleteBuffer(this.gl_id, buffer);\n\t}\n\n\t@inline deleteFramebuffer(framebuffer: WebGLFramebuffer): void {\n\t\tdeleteFramebuffer(this.gl_id, framebuffer);\n\t}\n\n\t@inline deleteProgram(program: WebGLProgram): void {\n\t\tdeleteProgram(this.gl_id, program);\n\t}\n\n\t@inline deleteRenderbuffer(renderbuffer: WebGLRenderbuffer): void {\n\t\tdeleteRenderbuffer(this.gl_id, renderbuffer);\n\t}\n\t@inline deleteShader(shader: WebGLShader): void {\n\t\tdeleteShader(this.gl_id, shader);\n\t}\n\t@inline deleteTexture(texture: WebGLTexture): void {\n\t\tdeleteTexture(this.gl_id, texture);\n\t}\n\n\t@inline depthFunc(func: GLenum): void {\n\t\tdepthFunc(this.gl_id, func);\n\t}\n\t@inline depthMask(flag: GLboolean): void {\n\t\tdepthMask(this.gl_id, flag);\n\t}\n\t@inline depthRange(zNear: GLclampf, zFar: GLclampf): void {\n\t\tdepthRange(this.gl_id, zNear, zFar);\n\t}\n\n\t@inline detachShader(program: WebGLProgram, shader: WebGLShader): void {\n\t\tdetachShader(this.gl_id, program, shader);\n\t}\n\t@inline disable(cap: GLenum): void {\n\t\tdisable(this.gl_id, cap);\n\t}\n\t@inline disableVertexAttribArray(index: GLuint): void {\n\t\tdisableVertexAttribArray(this.gl_id, index);\n\t}\n\t@inline drawArrays(mode: GLenum, first: GLint, count: GLsizei): void {\n\t\tdrawArrays(this.gl_id, mode, first, count)\n\t}\n\t@inline drawElements(mode: GLenum, count: GLsizei, typ: GLenum, offset: GLintptr): void {\n\t\tdrawElements(this.gl_id, mode, count, typ, offset);\n\t}\n\n\t@inline enable(cap: GLenum): void {\n\t\tenable(this.gl_id, cap);\n\t}\n\n\t@inline enableVertexAttribArray(index: GLuint): void {\n\t\tenableVertexAttribArray(this.gl_id, index);\n\t}\n\t@inline finish(): void {\n\t\tfinish(this.gl_id);\n\t}\n\t@inline flush(): void {\n\t\tflush(this.gl_id);\n\t}\n\t@inline framebufferRenderbuffer(target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: WebGLRenderbuffer): void {\n\t\tframebufferRenderbuffer(this.gl_id, target, attachment, renderbuffertarget, renderbuffer);\n\t}\n\t@inline framebufferTexture2D(target: GLenum, attachment: GLenum, textarget: GLenum, texture: WebGLTexture, level: GLint): void {\n\t\tframebufferTexture2D(this.gl_id, target, attachment, textarget, texture, level);\n\t}\n\t@inline frontFace(mode: GLenum): void {\n\t\tfrontFace(this.gl_id, mode);\n\t}\n\n\t@inline generateMipmap(target: GLenum): void {\n\t\tgenerateMipmap(this.gl_id, target)\n\t}\n\n\t@inline getActiveAttrib(program: WebGLProgram, index: GLuint): WebGLActiveInfo {\n\t\treturn getActiveAttrib(this.gl_id, program, index);\n\t}\n\t@inline getActiveUniform(program: WebGLProgram, index: GLuint): WebGLActiveInfo {\n\t\treturn getActiveUniform(this.gl_id, program, index);\n\t}\n\t@inline getAttachedShaders(program: WebGLProgram): sequence<WebGLShader> {\n\t\treturn getAttachedShaders(this.gl_id, program);\n\t}\n\n\t@inline getAttribLocation(program: WebGLProgram, name: string): GLint {\n\t\treturn getAttribLocation(this.gl_id, program, name);\n\t}\n\n\t@inline getBufferParameter(target: GLenum, pname: GLenum): externref {\n\t\treturn getBufferParameter(this.gl_id, target, pname);\n\t}\n\t@inline getParameter(pname: GLenum): externref {\n\t\treturn getParameter(this.gl_id, pname);\n\t}\n\n\t@inline getError(): GLenum {\n\t\treturn getError(this.gl_id);\n\t}\n\n\t@inline getFramebufferAttachmentParameter(target: GLenum, attachment: GLenum, pname: GLenum): externref {\n\t\treturn getFramebufferAttachmentParameter(this.gl_id, target, attachment, pname);\n\t}\n\t@inline getProgramParameter(program: WebGLProgram, pname: GLenum): bool {\n\t\treturn getProgramParameter(this.gl_id, program, pname);\n\t}\n\t@inline getProgramInfoLog(program: WebGLProgram): DOMString {\n\t\treturn getProgramInfoLog(this.gl_id, program);\n\t}\n\t@inline getRenderbufferParameter(target: GLenum, pname: GLenum): externref {\n\t\treturn getRenderbufferParameter(this.gl_id, target, pname);\n\t}\n\t@inline getShaderParameter(shader: WebGLShader, pname: GLenum): bool {\n\t\treturn getShaderParameter(this.gl_id, shader, pname);\n\t}\n\t@inline getShaderPrecisionFormat(shadertype: GLenum, precisiontype: GLenum): WebGLShaderPrecisionFormat {\n\t\treturn getShaderPrecisionFormat(this.gl_id, shadertype, precisiontype);\n\t}\n\n\t@inline getShaderInfoLog(shader: WebGLShader): DOMString {\n\t\treturn getShaderInfoLog(this.gl_id, shader);\n\t}\n\n\t@inline getShaderSource(shader: WebGLShader): DOMString {\n\t\treturn getShaderSource(this.gl_id, shader);\n\t}\n\n\t@inline getTexParameter(target: GLenum, pname: GLenum): externref {\n\t\treturn getTexParameter(this.gl_id, target, pname);\n\t}\n\n\t@inline getUniform(program: WebGLProgram, location: WebGLUniformLocation): externref {\n\t\treturn getUniform(this.gl_id, program, location);\n\t}\n\n\t@inline getUniformLocation(program: WebGLProgram, name: string): WebGLUniformLocation {\n\t\treturn getUniformLocation(this.gl_id, program, name);\n\t}\n\n\t@inline getVertexAttrib(index: GLuint, pname: GLenum): externref {\n\t\treturn getVertexAttrib(this.gl_id, index, pname);\n\t}\n\n\t@inline getVertexAttribOffset(index: GLuint, pname: GLenum): GLsizeiptr {\n\t\treturn getVertexAttribOffset(this.gl_id, index, pname);\n\t}\n\n\t@inline hint(target: GLenum, mode: GLenum): void {\n\t\thint(this.gl_id, target, mode);\n\t}\n\n\t@inline isBuffer(buffer: WebGLBuffer): GLboolean {\n\t\treturn isBuffer(this.gl_id, buffer);\n\t}\n\t@inline isEnabled(cap: GLenum): GLboolean {\n\t\treturn isEnabled(this.gl_id, cap);\n\t}\n\t@inline isFramebuffer(framebuffer: WebGLFramebuffer): GLboolean {\n\t\treturn isFramebuffer(this.gl_id, framebuffer);\n\t}\n\t@inline isProgram(program: WebGLProgram): GLboolean {\n\t\treturn isProgram(this.gl_id, program);\n\t}\n\t@inline isRenderbuffer(renderbuffer: WebGLRenderbuffer): GLboolean {\n\t\treturn isRenderbuffer(this.gl_id, renderbuffer);\n\t}\n\t@inline isShader(shader: WebGLShader): GLboolean {\n\t\treturn isShader(this.gl_id, shader);\n\t}\n\t@inline isTexture(texture: WebGLTexture): GLboolean {\n\t\treturn isTexture(this.gl_id, texture);\n\t}\n\t@inline lineWidth(width: GLfloat): void {\n\t\tlineWidth(this.gl_id, width);\n\t}\n\t@inline linkProgram(program: WebGLProgram): void {\n\t\tlinkProgram(this.gl_id, program);\n\t}\n\t@inline pixelStorei(pname: GLenum, param: GLint): void {\n\t\tpixelStorei(this.gl_id, pname, param);\n\t}\n\t@inline polygonOffset(factor: GLfloat, units: GLfloat): void {\n\t\tpolygonOffset(this.gl_id, factor, units);\n\t}\n\n\t@inline readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei,\n\t\tformat: GLenum, typ: GLenum, pixels: ArrayBufferView): void {\n\t\treadPixels(this.gl_id, x, y, width, height, format, typ, pixels);\n\t}\n\n\t@inline renderbufferStorage(target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei): void {\n\t\trenderbufferStorage(this.gl_id, target, internalformat, width, height);\n\t}\n\t@inline sampleCoverage(value: GLclampf, invert: GLboolean): void {\n\t\tsampleCoverage(this.gl_id, value, invert);\n\t}\n\t@inline scissor(x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {\n\t\tscissor(this.gl_id, x, y, width, height);\n\t}\n\n\t@inline shaderSource(shader: WebGLShader, source: string): void {\n\t\tshaderSource(this.gl_id, shader, source);\n\t}\n\n\t@inline stencilFunc(func: GLenum, ref: GLint, mask: GLuint): void {\n\t\tstencilFunc(this.gl_id, func, ref, mask);\n\t}\n\t@inline stencilFuncSeparate(face: GLenum, func: GLenum, ref: GLint, mask: GLuint): void {\n\t\tstencilFuncSeparate(this.gl_id, face, func, ref, mask);\n\t}\n\t@inline stencilMask(mask: GLuint): void {\n\t\tstencilMask(this.gl_id, mask);\n\t}\n\t@inline stencilMaskSeparate(face: GLenum, mask: GLuint): void {\n\t\tstencilMaskSeparate(this.gl_id, face, mask);\n\t}\n\t@inline stencilOp(fail: GLenum, zfail: GLenum, zpass: GLenum): void {\n\t\tstencilOp(this.gl_id, fail, zfail, zpass);\n\t}\n\t@inline stencilOpSeparate(face: GLenum, fail: GLenum, zfail: GLenum, zpass: GLenum): void {\n\t\tstencilOpSeparate(this.gl_id, face, fail, zfail, zpass);\n\t}\n\n\t@inline texImage2D(target: GLenum, level: GLint, internalformat: GLenum,\n\t\tformat: GLenum, typ: GLenum, image: ImageData): void {\n\t\ttexImage2D(this.gl_id, target, level, internalformat, format, typ, image);\n\t}\n\n\t@inline texParameterf(target: GLenum, pname: GLenum, param: GLfloat): void {\n\t\ttexParameterf(this.gl_id, target, pname, param);\n\t}\n\t@inline texParameteri(target: GLenum, pname: GLenum, param: GLint): void {\n\t\ttexParameteri(this.gl_id, target, pname, param);\n\t}\n\n\t@inline texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint,\n\t\tformat: GLenum, typ: GLenum, pixels: ImageData): void {\n\t\ttexSubImage2D(this.gl_id, target, level, xoffset, yoffset, format, typ, pixels);\n\t}\n\n\t@inline uniform1f(location: WebGLUniformLocation, x: GLfloat): void {\n\t\tuniform1f(this.gl_id, location, x);\n\t}\n\t@inline uniform1fv(location: WebGLUniformLocation, v: StaticArray<GLfloat>): void {\n\t\tuniform1fv(this.gl_id, location, v);\n\t}\n\n\t@inline uniform1i(location: WebGLUniformLocation, x: GLint): void {\n\t\tuniform1i(this.gl_id, location, x);\n\t}\n\t@inline uniform1iv(location: WebGLUniformLocation, v: StaticArray<GLint>): void {\n\t\tuniform1iv(this.gl_id, location, v);\n\t}\n\n\t@inline uniform2f(location: WebGLUniformLocation, x: GLfloat, y: GLfloat): void {\n\t\tuniform2f(this.gl_id, location, x, y);\n\t}\n\t@inline uniform2fv(location: WebGLUniformLocation, v: StaticArray<GLfloat>): void {\n\t\tuniform2fv(this.gl_id, location, v);\n\t}\n\n\t@inline uniform2i(location: WebGLUniformLocation, x: GLint, y: GLint): void {\n\t\tuniform2i(this.gl_id, location, x, y);\n\t}\n\t@inline uniform2iv(location: WebGLUniformLocation, v: StaticArray<GLint>): void {\n\t\tuniform2iv(this.gl_id, location, v);\n\t}\n\n\t@inline uniform3f(location: WebGLUniformLocation, x: GLfloat, y: GLfloat, z: GLfloat): void {\n\t\tuniform3f(this.gl_id, location, x, y, z);\n\t}\n\t@inline uniform3fv(location: WebGLUniformLocation, v: StaticArray<GLfloat>): void {\n\t\tuniform3fv(this.gl_id, location, v);\n\t}\n\n\t@inline uniform3i(location: WebGLUniformLocation, x: GLint, y: GLint, z: GLint): void {\n\t\tuniform3i(this.gl_id, location, x, y, z);\n\t}\n\t@inline uniform3iv(location: WebGLUniformLocation, v: StaticArray<GLint>): void {\n\t\tuniform3iv(this.gl_id, location, v);\n\t}\n\n\t@inline uniform4f(location: WebGLUniformLocation, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat): void {\n\t\tuniform4f(this.gl_id, location, x, y, z, w);\n\t}\n\n\t@inline uniform4fv(location: WebGLUniformLocation, v: StaticArray<GLfloat>): void {\n\t\tuniform4fv(this.gl_id, location, v);\n\t}\n\n\t@inline uniform4i(location: WebGLUniformLocation, x: GLint, y: GLint, z: GLint, w: GLint): void {\n\t\tuniform4i(this.gl_id, location, x, y, z, w);\n\t}\n\n\t@inline uniform4iv(location: WebGLUniformLocation, v: StaticArray<GLint>): void {\n\t\tuniform4iv(this.gl_id, location, v);\n\t}\n\n\t@inline uniformMatrix2fv(location: WebGLUniformLocation, transpose: GLboolean, value: StaticArray<GLfloat>): void {\n\t\tuniformMatrix2fv(this.gl_id, location, transpose, value);\n\t}\n\n\t@inline uniformMatrix3fv(location: WebGLUniformLocation, transpose: GLboolean, value: StaticArray<GLfloat>): void {\n\t\tuniformMatrix3fv(this.gl_id, location, transpose, value);\n\t}\n\n\t@inline uniformMatrix4fv(location: WebGLUniformLocation, transpose: GLboolean, value: StaticArray<GLfloat>): void {\n\t\tuniformMatrix4fv(this.gl_id, location, transpose, value);\n\t}\n\t@inline useProgram(program: WebGLProgram): void {\n\t\tuseProgram(this.gl_id, program);\n\t}\n\t@inline validateProgram(program: WebGLProgram): void {\n\t\tvalidateProgram(this.gl_id, program);\n\t}\n\n\t@inline vertexAttrib1f(indx: GLuint, x: GLfloat): void {\n\t\tvertexAttrib1f(this.gl_id, indx, x);\n\t}\n\n\t@inline vertexAttrib1fv(indx: GLuint, values: StaticArray<GLfloat>): void {\n\t\tvertexAttrib1fv(this.gl_id, indx, values);\n\t}\n\n\t@inline vertexAttrib2f(indx: GLuint, x: GLfloat, y: GLfloat): void {\n\t\tvertexAttrib2f(this.gl_id, indx, x, y);\n\t}\n\n\t@inline vertexAttrib2fv(indx: GLuint, values: StaticArray<GLfloat>): void {\n\t\tvertexAttrib2fv(this.gl_id, indx, values);\n\t}\n\n\t@inline vertexAttrib3f(indx: GLuint, x: GLfloat, y: GLfloat, z: GLfloat): void {\n\t\tvertexAttrib3f(this.gl_id, indx, x, y, z);\n\t}\n\t@inline vertexAttrib3fv(indx: GLuint, values: StaticArray<GLfloat>): void {\n\t\tvertexAttrib3fv(this.gl_id, indx, values);\n\t}\n\n\t@inline vertexAttrib4f(indx: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat): void {\n\t\tvertexAttrib4f(this.gl_id, indx, x, y, z, w)\n\t}\n\t@inline vertexAttrib4fv(indx: GLuint, values: StaticArray<GLfloat>): void {\n\t\tvertexAttrib4fv(this.gl_id, indx, values)\n\t}\n\n\t@inline vertexAttribPointer(indx: GLint, size: GLint, typ: GLenum,\n\t\tnormalized: GLint, stride: GLsizei, offset: GLintptr): void {\n\t\tvertexAttribPointer(this.gl_id, indx, size, typ, normalized, stride, offset);\n\t}\n\n\t@inline viewport(x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {\n\t\tviewport(this.gl_id, x, y, width, height);\n\t}\n\n\t@inline copyBufferSubData(readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr,\n\t\twriteOffset: GLintptr, size: GLsizeiptr): void {\n\t\tcopyBufferSubData(this.gl_id, readTarget, writeTarget, readOffset, writeOffset, size);\n\t}\n\n\t@inline getBufferSubData(gl: WebGLRenderingContext, target: GLenum, srcByteOffset: GLintptr, dstBuffer: ArrayBufferView,\n\t\tdstOffset: GLuint = 0, length: GLuint = 0): void {\n\t\tgetBufferSubData(this.gl_id, target, srcByteOffset, dstBuffer, dstOffset, length);\n\t}\n\n\t@inline blitFramebuffer(gl: WebGLRenderingContext, srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint,\n\t\tdstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint,\n\t\tmask: GLbitfield, filter: GLenum): void {\n\t\tblitFramebuffer(this.gl_id, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);\n\t}\n\t@inline framebufferTextureLayer(target: GLenum, attachment: GLenum, texture: WebGLTexture, level: GLint, layer: GLint): void {\n\t\tframebufferTextureLayer(this.gl_id, target, attachment, texture, level, layer);\n\t}\n\t@inline invalidateFramebuffer(target: GLenum, attachments: sequence<GLenum>): void {\n\t\tinvalidateFramebuffer(this.gl_id, target, attachments);\n\t}\n\n\t@inline invalidateSubFramebuffer(target: GLenum, attachments: sequence<GLenum>,\n\t\tx: GLint, y: GLint, width: GLsizei, height: GLsizei): void {\n\t\tinvalidateSubFramebuffer(this.gl_id, target, attachments, x, y, width, height);\n\t}\n\t@inline readBuffer(src: GLenum): void {\n\t\treadBuffer(this.gl_id, src);\n\t}\n\n\t@inline getInternalformatParameter(target: GLenum, internalformat: GLenum, pname: GLenum): externref {\n\t\treturn getInternalformatParameter(this.gl_id, target, internalformat, pname);\n\t}\n\t@inline renderbufferStorageMultisample(target: GLenum, samples: GLsizei, internalformat: GLenum,\n\t\twidth: GLsizei, height: GLsizei): void {\n\t\trenderbufferStorageMultisample(this.gl_id, target, samples, internalformat, width, height);\n\t}\n\n\t@inline texStorage2D(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei): void {\n\t\ttexStorage2D(this.gl_id, target, levels, internalformat, width, height);\n\t}\n\t@inline texStorage3D(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei,\n\t\theight: GLsizei, depth: GLsizei): void {\n\t\ttexStorage3D(this.gl_id, target, levels, internalformat, width, height, depth);\n\t}\n\n\t@inline texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei,\n\t\tdepth: GLsizei, border: GLint, format: GLenum, typ: GLenum, pboOffset: GLintptr): void {\n\t\ttexImage3D(this.gl_id, target, level, internalformat, width, height, depth, border, format, typ, pboOffset);\n\t}\n\n\t@inline texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint,\n\t\twidth: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, typ: GLenum,\n\t\tpboOffset: GLintptr): void {\n\t\ttexSubImage3D(this.gl_id, target, level, xoffset, yoffset, zoffset,\n\t\t\twidth, height, depth, format, typ, pboOffset);\n\t}\n\n\t@inline copyTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint,\n\t\tx: GLint, y: GLint, width: GLsizei, height: GLsizei): void {\n\t\tcopyTexSubImage3D(this.gl_id, target, level, xoffset, yoffset, zoffset, x, y, width, height);\n\t}\n\n\t@inline compressedTexImage3D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei,\n\t\theight: GLsizei, depth: GLsizei, border: GLint, imageSize: GLsizei, offset: GLintptr): void {\n\t\tcompressedTexImage3D(this.gl_id, target, level, internalformat, width, height,\n\t\t\tdepth, border, imageSize, offset);\n\t}\n\n\t@inline compressedTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint,\n\t\tzoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei,\n\t\tformat: GLenum, imageSize: GLsizei, offset: GLintptr): void {\n\t\tcompressedTexSubImage3D(this.gl_id, target, level, xoffset, yoffset, zoffset, width, height, depth,\n\t\t\tformat, imageSize, offset);\n\t}\n\n\t@inline getFragDataLocation(program: WebGLProgram, name: DOMString): GLint {\n\t\treturn getFragDataLocation(this.gl_id, program, name);\n\t}\n\n\t@inline uniform1ui(location: WebGLUniformLocation, v0: GLuint): void {\n\t\tuniform1ui(this.gl_id, location, v0);\n\t}\n\t@inline uniform2ui(location: WebGLUniformLocation, v0: GLuint, v1: GLuint): void {\n\t\tuniform2ui(this.gl_id, location, v0, v1);\n\t}\n\t@inline uniform3ui(location: WebGLUniformLocation, v0: GLuint, v1: GLuint, v2: GLuint): void {\n\t\tuniform3ui(this.gl_id, location, v0, v1, v2);\n\t}\n\t@inline uniform4ui(location: WebGLUniformLocation, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint): void {\n\t\tuniform4ui(this.gl_id, location, v0, v1, v2, v3);\n\t}\n\n\t@inline uniform1uiv(location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = 0,\n\t\tsrcLength: GLuint = 0): void {\n\t\tuniform1uiv(this.gl_id, location, data, srcOffset, srcLength);\n\t}\n\n\t@inline uniform2uiv(location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void {\n\t\tuniform2uiv(this.gl_id, location, data, srcOffset, srcLength);\n\t}\n\t@inline uniform3uiv(location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void {\n\t\tuniform3uiv(this.gl_id, location, data, srcOffset, srcLength);\n\t}\n\t@inline uniform4uiv(location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = 0,\n\t\tsrcLength: GLuint = 0): void {\n\t\tuniform4uiv(this.gl_id, location, data, srcOffset, srcLength);\n\t}\n\t@inline uniformMatrix3x2fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List,\n\t\tsrcOffset: GLuint = 0, srcLength: GLuint = 0): void {\n\t\tuniformMatrix3x2fv(this.gl_id, location, transpose, data, srcOffset, srcLength);\n\t}\n\t@inline uniformMatrix4x2fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List,\n\t\tsrcOffset: GLuint = 0, srcLength: GLuint = 0): void {\n\t\tuniformMatrix4x2fv(this.gl_id, location, transpose, data, srcOffset, srcLength);\n\t}\n\n\t@inline uniformMatrix2x3fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List,\n\t\tsrcOffset: GLuint = 0, srcLength: GLuint = 0): void {\n\t\tuniformMatrix2x3fv(this.gl_id, location, transpose, data, srcOffset, srcLength);\n\t}\n\t@inline uniformMatrix4x3fv(gl: WebGLRenderingContext, location: WebGLUniformLocation, transpose: GLboolean, data: Float32List,\n\t\tsrcOffset: GLuint = 0, srcLength: GLuint = 0): void {\n\t\tuniformMatrix4x3fv(this.gl_id, location, transpose, data, srcOffset, srcLength);\n\t}\n\n\t@inline uniformMatrix2x4fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List,\n\t\tsrcOffset: GLuint = 0, srcLength: GLuint = 0): void {\n\t\tuniformMatrix2x4fv(this.gl_id, location, transpose, data, srcOffset, srcLength);\n\t}\n\t@inline uniformMatrix3x4fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List,\n\t\tsrcOffset: GLuint = 0, srcLength: GLuint = 0): void {\n\t\tuniformMatrix3x4fv(this.gl_id, location, transpose, data,\n\t\t\tsrcOffset, srcLength);\n\t}\n\n\t/* Vertex attribs */\n\t@inline vertexAttribI4i(index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint): void {\n\t\tvertexAttribI4i(this.gl_id, index, x, y, z, w)\n\t}\n\t@inline vertexAttribI4iv(index: GLuint, values: Int32List): void {\n\t\tvertexAttribI4iv(this.gl_id, index, values);\n\t}\n\t@inline vertexAttribI4ui(index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint): void {\n\t\tvertexAttribI4ui(this.gl_id, index, x, y, z, w);\n\t}\n\t@inline vertexAttribI4uiv(index: GLuint, values: Uint32List): void {\n\t\tvertexAttribI4uiv(this.gl_id, index, values);\n\t}\n\t@inline vertexAttribIPointer(index: GLuint, size: GLint, typ: GLenum, stride: GLsizei, offset: GLintptr): void {\n\t\tvertexAttribIPointer(this.gl_id, index, size, typ, stride, offset)\n\t}\n\n\t@inline vertexAttribDivisor(index: GLuint, divisor: GLuint): void {\n\t\tvertexAttribDivisor(this.gl_id, index, divisor);\n\t}\n\t@inline drawArraysInstanced(mode: GLenum, first: GLint, count: GLsizei, instanceCount: GLsizei): void {\n\t\tdrawArraysInstanced(this.gl_id, mode, first, count, instanceCount);\n\t}\n\t@inline drawElementsInstanced(mode: GLenum, count: GLsizei, typ: GLenum, offset: GLintptr, instanceCount: GLsizei): void {\n\t\tdrawElementsInstanced(this.gl_id, mode, count, typ, offset, instanceCount);\n\t}\n\t@inline drawRangeElements(mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, typ: GLenum, offset: GLintptr): void {\n\t\tdrawRangeElements(this.gl_id, mode, start, end, count, typ, offset);\n\t}\n\n\t@inline drawBuffers(gl: WebGLRenderingContext, buffers: sequence<GLenum>): void {\n\t\tdrawBuffers(this.gl_id, buffers);\n\t}\n\n\t@inline clearBufferfv(buffer: GLenum, drawbuffer: GLint, values: Float32List, srcOffset: GLuint = 0): void {\n\t\tclearBufferfv(this.gl_id, buffer, drawbuffer, values, srcOffset);\n\t}\n\t@inline clearBufferiv(buffer: GLenum, drawbuffer: GLint, values: Int32List,\n\t\tsrcOffset: GLuint = 0): void {\n\t\tclearBufferiv(this.gl_id, buffer, drawbuffer, values, srcOffset);\n\t}\n\t@inline clearBufferuiv(buffer: GLenum, drawbuffer: GLint, values: Uint32List,\n\t\tsrcOffset: GLuint = 0): void {\n\t\tclearBufferuiv(this.gl_id, buffer, drawbuffer, values, srcOffset);\n\t}\n\n\t@inline clearBufferfi(buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint): void {\n\t\tclearBufferfi(this.gl_id, buffer, drawbuffer, depth, stencil);\n\t}\n\n\t/* Query Objects */\n\t@inline createQuery(): WebGLQuery {\n\t\treturn createQuery(this.gl_id);\n\t}\n\t@inline deleteQuery(query: WebGLQuery): void {\n\t\tdeleteQuery(this.gl_id, query);\n\t}\n\n\t@inline isQuery(query: WebGLQuery): GLboolean {\n\t\treturn isQuery(this.gl_id, query);\n\t}\n\t@inline beginQuery(target: GLenum, query: WebGLQuery): void {\n\t\tbeginQuery(this.gl_id, target, query);\n\t}\n\t@inline endQuery(target: GLenum): void {\n\t\tendQuery(this.gl_id, target)\n\t}\n\t@inline getQuery(target: GLenum, pname: GLenum): WebGLQuery {\n\t\treturn getQuery(this.gl_id, target, pname);\n\t}\n\t@inline getQueryParameter(query: WebGLQuery, pname: GLenum): externref {\n\t\treturn getQueryParameter(this.gl_id, query, pname);\n\t}\n\n\t@inline createSampler(): WebGLSampler {\n\t\treturn createSampler(this.gl_id);\n\t}\n\n\t@inline deleteSampler(sampler: WebGLSampler): void {\n\t\tdeleteSampler(this.gl_id, sampler);\n\t}\n\n\t@inline isSampler(sampler: WebGLSampler): GLboolean {\n\t\treturn isSampler(this.gl_id, sampler);\n\t}\n\n\t@inline bindSampler(unit: GLuint, sampler: WebGLSampler): void {\n\t\tbindSampler(this.gl_id, unit, sampler);\n\t}\n\t@inline samplerParameteri(sampler: WebGLSampler, pname: GLenum, param: GLint): void {\n\t\tsamplerParameteri(this.gl_id, sampler, pname, param);\n\t}\n\t@inline samplerParameterf(sampler: WebGLSampler, pname: GLenum, param: GLfloat): void {\n\t\tsamplerParameterf(this.gl_id, sampler, pname, param);\n\t}\n\t@inline getSamplerParameter(sampler: WebGLSampler, pname: GLenum): externref {\n\t\treturn getSamplerParameter(this.gl_id, sampler, pname);\n\t}\n\n\t/* Sync objects */\n\t@inline fenceSync(condition: GLenum, flags: GLbitfield): WebGLSync {\n\t\treturn fenceSync(this.gl_id, condition, flags);\n\t}\n\t/*[WebGLHandlesContextLoss]*/\n\t@inline isSync(sync: WebGLSync): GLboolean {\n\t\treturn isSync(this.gl_id, sync);\n\t}\n\n\t@inline deleteSync(sync: WebGLSync): void {\n\t\tdeleteSync(this.gl_id, sync);\n\t}\n\n\t@inline clientWaitSync(sync: WebGLSync, flags: GLbitfield, timeout: GLuint64): GLenum {\n\t\treturn clientWaitSync(this.gl_id, sync, flags, timeout);\n\t}\n\t@inline waitSync(sync: WebGLSync, flags: GLbitfield, timeout: GLint64): void {\n\t\twaitSync(this.gl_id, sync, flags, timeout);\n\t}\n\t@inline getSyncParameter(sync: WebGLSync, pname: GLenum): externref {\n\t\treturn getSyncParameter(this.gl_id, sync, pname);\n\t}\n\n\t@inline createTransformFeedback(): WebGLTransformFeedback {\n\t\treturn createTransformFeedback(this.gl_id);\n\t}\n\t@inline deleteTransformFeedback(tf: WebGLTransformFeedback): void {\n\t\tdeleteTransformFeedback(this.gl_id, tf);\n\t}\n\n\t@inline isTransformFeedback(tf: WebGLTransformFeedback): GLboolean {\n\t\treturn isTransformFeedback(this.gl_id, tf);\n\t}\n\t@inline bindTransformFeedback(target: GLenum, tf: WebGLTransformFeedback): void {\n\t\tbindTransformFeedback(this.gl_id, target, tf);\n\t}\n\t@inline beginTransformFeedback(primitiveMode: GLenum): void {\n\t\tbeginTransformFeedback(this.gl_id, primitiveMode);\n\t}\n\n\t@inline endTransformFeedback(): void {\n\t\tendTransformFeedback(this.gl_id);\n\t}\n\n\t@inline transformFeedbackVaryings(program: WebGLProgram, varyings: sequence<DOMString>, bufferMode: GLenum): void {\n\t\ttransformFeedbackVaryings(this.gl_id, program, varyings, bufferMode);\n\t}\n\t@inline getTransformFeedbackVarying(program: WebGLProgram, index: GLuint): WebGLActiveInfo {\n\t\treturn getTransformFeedbackVarying(this.gl_id, program, index);\n\t}\n\t@inline pauseTransformFeedback(): void {\n\t\tpauseTransformFeedback(this.gl_id);\n\t}\n\n\t@inline resumeTransformFeedback(): void {\n\t\tresumeTransformFeedback(this.gl_id);\n\t}\n\n\t@inline bindBufferBase(target: GLenum, index: GLuint, buffer: WebGLBuffer): void {\n\t\tbindBufferBase(this.gl_id, target, index, buffer);\n\t}\n\t@inline bindBufferRange(target: GLenum, index: GLuint, buffer: WebGLBuffer,\n\t\toffset: GLintptr, size: GLsizeiptr): void {\n\t\tbindBufferRange(this.gl_id, target, index, buffer, offset, size);\n\t}\n\t@inline getIndexedParameter(target: GLenum, index: GLuint): externref {\n\t\treturn getIndexedParameter(this.gl_id, target, index);\n\t}\n\t@inline getUniformIndices(program: WebGLProgram, uniformNames: sequence<DOMString>): sequence<GLuint> {\n\t\treturn getUniformIndices(this.gl_id, program, uniformNames);\n\t}\n\t@inline getActiveUniforms(program: WebGLProgram, uniformIndices: sequence<GLuint>, pname: GLenum): externref {\n\t\treturn getActiveUniforms(this.gl_id, program, uniformIndices, pname);\n\t}\n\t@inline getUniformBlockIndex(program: WebGLProgram, uniformBlockName: DOMString): GLuint {\n\t\treturn getUniformBlockIndex(this.gl_id, program, uniformBlockName);\n\t}\n\t@inline getActiveUniformBlockParameter(program: WebGLProgram, uniformBlockIndex: GLuint, pname: GLenum): externref {\n\t\treturn getActiveUniformBlockParameter(this.gl_id, program, uniformBlockIndex, pname);\n\t}\n\t@inline getActiveUniformBlockName(program: WebGLProgram, uniformBlockIndex: GLuint): DOMString {\n\t\treturn getActiveUniformBlockName(this.gl_id, program, uniformBlockIndex);\n\t}\n\t@inline uniformBlockBinding(program: WebGLProgram, uniformBlockIndex: GLuint, _uniformBlockBinding: GLuint): void {\n\t\tuniformBlockBinding(this.gl_id, program, uniformBlockIndex, _uniformBlockBinding);\n\t}\n\n\t@inline createVertexArray(): WebGLVertexArrayObject {\n\t\treturn createVertexArray(this.gl_id);\n\t}\n\t@inline deleteVertexArray(vertexArray: WebGLVertexArrayObject): void {\n\t\tdeleteVertexArray(this.gl_id, vertexArray);\n\t}\n\n\t@inline isVertexArray(vertexArray: WebGLVertexArrayObject): GLboolean {\n\t\treturn isVertexArray(this.gl_id, vertexArray);\n\t}\n\n\t@inline bindVertexArray(array: WebGLVertexArrayObject): void {\n\t\tbindVertexArray(this.gl_id, array)\n\t}\n\n}\n\n//const gl: WebGLRenderingContext = canvas.getContext(\"webgl\");\n//gl.compileShader(\".....\");","import { WebGLRenderingContext } from \"../externals/WebGL\";\nimport { ShaderMaterial } from \"./ShaderMaterial\";\n\nconst vertexShaderCode: string = `\n    precision highp float;\n    attribute vec2 position;\n\n    void  main() {\n        gl_Position = vec4( position, 0.0, 1.0 );\n    }\n`;\n\nconst fragmentShaderCode: string = `\n    precision highp float;\n\n    void main() {\n        gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n    }\n`;\n\nexport class TestTriangle {\n    private readonly _gl: WebGLRenderingContext;\n    private readonly _shaderMaterial: ShaderMaterial;\n\n    constructor(gl: WebGLRenderingContext) {\n        this._gl = gl;\n        this._shaderMaterial = new ShaderMaterial(gl);\n        this._shaderMaterial.compile(vertexShaderCode, fragmentShaderCode);\n    }\n\n    public update(deltaMs: f32): void {}\n\n    public render(): void {\n        this._shaderMaterial.activate();\n\n        const buffer = this._gl.createBuffer();\n        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffer);\n\n        const triangle_data: StaticArray<f32> = [0.0, 0.5, -0.5, -0.5, 0.5, -0.5];\n        this._gl.bufferData<f32>(this._gl.ARRAY_BUFFER, triangle_data, this._gl.STATIC_DRAW);\n\n        // attribute | dimensions | data_type | normalize | stride | offset\n\n        //                      mode | first vertex | count\n        this._gl.drawArrays(this._gl.TRIANGLE_STRIP, 0, 3);\n    }\n}\n","import { WebGLRenderingContext } from \"../externals/WebGL\";\nimport { TestTriangle } from \"./TestTriangle\";\n\nexport class Renderer {\n    private _triangle: TestTriangle;\n    private _gl: WebGLRenderingContext;\n\n    constructor(canvasId: string, contextType: string) {\n        this._gl = new WebGLRenderingContext(canvasId, contextType);\n        this._triangle = new TestTriangle(this._gl);\n    }\n\n    updateFrame(): void {\n        this._triangle.update(0);\n    }\n\n    renderFrame(): void {\n        this._gl.clearColor(0.392, 0.584, 0.929, 1.0);\n        this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT);\n\n        this._triangle.render();\n    }\n}\n\n/*\nimport {\n    WebGLRenderingContext,\n    WebGLShader,\n    WebGLProgram,\n    WebGLBuffer,\n    GLint,\n} from \"./../externals/WebGL\";\n\nconst VERTEX_SHADER_CODE: string = `\n   precision highp float;\n \n   attribute vec2 position;\n \n   void main() {\n     gl_Position = vec4( position, 0.0, 1.0 );\n   }\n `;\n\nconst FRAGMENT_SHADER_CODE: string = `\n   precision highp float;\n \n   void main() {\n    gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n   }\n `;\n\nlet gl: WebGLRenderingContext;\nlet triangle_data: StaticArray<f32> = [];\nlet position_al: GLint;\n\nexport function initializeRenderer(): void {\n    gl = new WebGLRenderingContext(\"canvas-3d\", \"webgl2\");\n\n    let vertex_shader: WebGLShader = gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(vertex_shader, VERTEX_SHADER_CODE);\n    gl.compileShader(vertex_shader);\n\n    let fragment_shader: WebGLShader = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(fragment_shader, FRAGMENT_SHADER_CODE);\n    gl.compileShader(fragment_shader);\n\n    let program: WebGLProgram = gl.createProgram();\n\n    gl.attachShader(program, vertex_shader);\n    gl.attachShader(program, fragment_shader);\n\n    gl.linkProgram(program);\n\n    gl.useProgram(program);\n\n    let buffer: WebGLBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n    let position_al: GLint = gl.getAttribLocation(program, \"position\");\n    gl.enableVertexAttribArray(position_al);\n\n    triangle_data = [0.0, 0.5, -0.5, -0.5, 0.5, -0.5];\n}\n\nexport function displayLoop(): void {\n    if (gl) {\n        gl.bufferData<f32>(gl.ARRAY_BUFFER, triangle_data, gl.STATIC_DRAW);\n\n        //                      attribute | dimensions | data_type | normalize | stride | offset\n        gl.vertexAttribPointer(position_al, 2, gl.FLOAT, +false, 0, 0);\n\n        //                      mode | first vertex | count\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 3);\n    }\n}\n*/\n","import { AL_MASK, OBJECT, OBJECT_OVERHEAD, BLOCK_MAXSIZE, BLOCK_OVERHEAD, BLOCK, OBJECT_MAXSIZE } from \"./common\";\nimport { E_ALLOCATION_TOO_LARGE } from \"../util/error\";\n\n// === A minimal runtime stub ===\n\n// @ts-ignore: decorator\n@lazy var startOffset: usize = ((__heap_base + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n// @ts-ignore: decorator\n@lazy var offset: usize = startOffset;\n\nfunction maybeGrowMemory(newOffset: usize): void {\n  // assumes newOffset is aligned\n  var pagesBefore = memory.size();\n  var maxOffset = ((<usize>pagesBefore << 16) + AL_MASK) & ~AL_MASK;\n  if (newOffset > maxOffset) {\n    let pagesNeeded = <i32>(((newOffset - maxOffset + 0xffff) & ~0xffff) >>> 16);\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n    if (memory.grow(pagesWanted) < 0) {\n      if (memory.grow(pagesNeeded) < 0) unreachable(); // out of memory\n    }\n  }\n  offset = newOffset;\n}\n\n// @ts-ignore: decorator\n@inline function computeSize(size: usize): usize {\n  return ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __alloc(size: usize): usize {\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  var block = changetype<BLOCK>(offset);\n  var ptr = offset + BLOCK_OVERHEAD;\n  var payloadSize = computeSize(size);\n  maybeGrowMemory(ptr + payloadSize);\n  block.mmInfo = payloadSize;\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __realloc(ptr: usize, size: usize): usize {\n  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned\n  var block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\n  var actualSize = block.mmInfo;\n  var isLast = ptr + actualSize == offset;\n  var payloadSize = computeSize(size);\n  if (size > actualSize) {\n    if (isLast) { // last block: grow\n      if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n      maybeGrowMemory(ptr + payloadSize);\n      block.mmInfo = payloadSize;\n    } else { // copy to new block at least double the size\n      let newPtr = __alloc(max<usize>(payloadSize, actualSize << 1));\n      memory.copy(newPtr, ptr, actualSize);\n      block = changetype<BLOCK>((ptr = newPtr) - BLOCK_OVERHEAD);\n    }\n  } else if (isLast) { // last block: shrink\n    offset = ptr + payloadSize;\n    block.mmInfo = payloadSize;\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __free(ptr: usize): void {\n  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned\n  var block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\n  if (ptr + block.mmInfo == offset) { // last block: discard\n    offset = changetype<usize>(block);\n  }\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __reset(): void { // special\n  offset = startOffset;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __new(size: usize, id: u32): usize {\n  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  var ptr = __alloc(OBJECT_OVERHEAD + size);\n  var object = changetype<OBJECT>(ptr - BLOCK_OVERHEAD);\n  object.gcInfo = 0;\n  object.gcInfo2 = 0;\n  object.rtId = id;\n  object.rtSize = <u32>size;\n  return ptr + OBJECT_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __renew(oldPtr: usize, size: usize): usize {\n  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  var newPtr = __realloc(oldPtr - OBJECT_OVERHEAD, OBJECT_OVERHEAD + size);\n  changetype<OBJECT>(newPtr - BLOCK_OVERHEAD).rtSize = <u32>size;\n  return newPtr + OBJECT_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // nop\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  // nop\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __visit(ptr: usize, cookie: u32): void { // eslint-disable-line @typescript-eslint/no-unused-vars\n  // nop\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  // nop\n}\n","// Common error messages for use across the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_VALUEOUTOFRANGE: string = \"Value out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ILLEGALGENTYPE: string = \"Illegal generic type\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALLOCATION_TOO_LARGE: string = \"Allocation too large\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALREADY_PINNED: string = \"Object already pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOT_PINNED: string = \"Object is not pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_URI_MALFORMED: string = \"URI malformed\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDDATE: string = \"Invalid Date\";\n","import { WebGLProgram, WebGLRenderingContext } from \"../externals/WebGL\";\n\nexport class ShaderMaterial {\n    private _program: WebGLProgram = 0;\n    private readonly _gl: WebGLRenderingContext;\n\n    constructor(gl: WebGLRenderingContext) {\n        this._gl = gl;\n    }\n\n    public compile(vertexShaderCode: string, fragmentShaderCode: string): boolean {\n        if (this._program) {\n            throw new Error(`Material has been compiled before`);\n        }\n\n        const vertexShader = this._gl.createShader(this._gl.VERTEX_SHADER);\n        this._gl.shaderSource(vertexShader, vertexShaderCode);\n        this._gl.compileShader(vertexShader);\n\n        const fragmentShader = this._gl.createShader(this._gl.FRAGMENT_SHADER);\n        this._gl.shaderSource(fragmentShader, fragmentShaderCode);\n        this._gl.compileShader(fragmentShader);\n\n        this._program = this._gl.createProgram();\n\n        this._gl.attachShader(this._program, vertexShader);\n        this._gl.attachShader(this._program, fragmentShader);\n        this._gl.linkProgram(this._program);\n\n        // Uniform stuff.\n        // this._gl.getUniformLocation(this._program, \"\");\n\n        return true; // TODO: Check compilation status.\n    }\n\n    activate(): void {\n        this._gl.useProgram(this._program);\n\n        let position_al = this._gl.getAttribLocation(this._program, \"position\");\n        this._gl.vertexAttribPointer(position_al, 2, this._gl.FLOAT, +false, 0, 0);\n        this._gl.enableVertexAttribArray(position_al);\n    }\n}\n","import { Renderer } from \"./components/Renderer\";\n\nlet renderer: Renderer;\n\nexport function initialize(canvasId: string, contextType: string): boolean {\n    renderer = new Renderer(canvasId, contextType);\n    return true;\n}\n\nexport function updateFrame(): void {\n    renderer.updateFrame();\n}\n\nexport function renderFrame(): void {\n    renderer.renderFrame();\n}\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { OBJECT, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  var ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __instanceof(ptr: usize, classId: u32): bool { // keyword\n  var id = changetype<OBJECT>(ptr - TOTAL_OVERHEAD).rtId;\n  var rttiBase = __rtti_base;\n  if (id <= load<u32>(rttiBase)) {\n    do if (id == classId) return true;\n    while (id = changetype<Typeinfo>(rttiBase + sizeof<u32>() + id * offsetof<Typeinfo>()).base);\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newBuffer(size: usize, id: u32, data: usize = 0): usize {\n  var buffer = __new(size, id);\n  if (data) memory.copy(buffer, data, size);\n  return buffer;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  var bufferSize = <usize>length << alignLog2;\n  // make sure `buffer` is tracked by the shadow stack\n  var buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));\n  // ...since allocating the array may trigger GC steps\n  var array = __new(offsetof<i32[]>(), id);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"buffer\"));\n  __link(array, changetype<usize>(buffer), false);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"dataStart\"));\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\n  store<i32>(array, length, offsetof<i32[]>(\"length_\"));\n  return array;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __tostack(ptr: usize): usize { // eslint-disable-line\n  return ptr;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __alloc(size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ptr: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __new(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __renew(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ptr: usize, cookie: u32): void;\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    var index: usize = 0;\n    var total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n\n  /** Gets a pointer to a static chunk of memory of the given size. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function data<T>(size: T, align?: i32): usize;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __data_end: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare var __stack_pointer: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __heap_base: usize;\n\n/** Heap memory interface. */\nexport namespace heap {\n\n  /** Allocates a chunk of memory of at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function alloc(size: usize): usize {\n    return __alloc(size);\n  }\n\n  /** Reallocates a chunk of memory to have at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function realloc(ptr: usize, size: usize): usize {\n    return __realloc(ptr, size);\n  }\n\n  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function free(ptr: usize): void {\n    __free(ptr);\n  }\n\n  /** Dangerously resets the entire heap. Specific to the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function reset(): void {\n    if (isDefined(__reset)) {\n      __reset();\n    } else {\n      throw new Error(E_NOTIMPLEMENTED);\n    }\n  }\n}\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (<u32>dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src - dest - n <= -(n << 1)) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while (dest & 7) {\n          if (!n) return;\n          --n;\n          store<u8>(dest++, load<u8>(src++));\n        }\n        while (n >= 8) {\n          store<u64>(dest, load<u64>(src));\n          n    -= 8;\n          dest += 8;\n          src  += 8;\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while ((dest + n) & 7) {\n          if (!n) return;\n          store<u8>(dest + --n, load<u8>(src + n));\n        }\n        while (n >= 8) {\n          n -= 8;\n          store<u64>(dest + n, load<u64>(src + n));\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    let dend = dest + n;\n    store<u8>(dest, c);\n    store<u8>(dend - 1, c);\n    if (n <= 2) return;\n    store<u8>(dest, c, 1);\n    store<u8>(dest, c, 2);\n    store<u8>(dend - 2, c);\n    store<u8>(dend - 3, c);\n    if (n <= 6) return;\n    store<u8>(dest, c, 3);\n    store<u8>(dend - 4, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    dend = dest + n;\n    store<u32>(dest, c32);\n    store<u32>(dend - 4, c32);\n    if (n <= 8) return;\n    store<u32>(dest, c32, 4);\n    store<u32>(dest, c32, 8);\n    store<u32>(dend - 12, c32);\n    store<u32>(dend - 8, c32);\n    if (n <= 24) return;\n    store<u32>(dest, c32, 12);\n    store<u32>(dest, c32, 16);\n    store<u32>(dest, c32, 20);\n    store<u32>(dest, c32, 24);\n    store<u32>(dend - 28, c32);\n    store<u32>(dend - 24, c32);\n    store<u32>(dend - 20, c32);\n    store<u32>(dend - 16, c32);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest, c64, 8);\n      store<u64>(dest, c64, 16);\n      store<u64>(dest, c64, 24);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\n  if (vl == vr) return 0;\n  if (ASC_SHRINK_LEVEL < 2) {\n    if ((vl & 7) == (vr & 7)) {\n      while (vl & 7) {\n        if (!n) return 0;\n        let a = <i32>load<u8>(vl);\n        let b = <i32>load<u8>(vr);\n        if (a != b) return a - b;\n        n--; vl++; vr++;\n      }\n      while (n >= 8) {\n        if (load<u64>(vl) != load<u64>(vr)) break;\n        vl += 8;\n        vr += 8;\n        n  -= 8;\n      }\n    }\n  }\n  while (n--) {\n    let a = <i32>load<u8>(vl);\n    let b = <i32>load<u8>(vr);\n    if (a != b) return a - b;\n    vl++; vr++;\n  }\n  return 0;\n}\n"]}